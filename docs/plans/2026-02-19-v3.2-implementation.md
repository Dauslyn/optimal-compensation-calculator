# v3.2 Implementation Plan

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.

**Goal:** Fix capital gains / portfolio return decomposition, make lifetime winner the primary recommendation, speed up and correct Monte Carlo, add per-section advanced toggles for quick mode, add narrative synthesis, and surface a "My Current Strategy" 4th comparison slot.

**Architecture:** Six independent-ish features implemented in dependency order: engine correctness first (Task 1), then engine/type additions (Tasks 2–3), then UI (Tasks 4–6). Each task is self-contained with its own tests and commit.

**Tech Stack:** TypeScript, Vitest, React 19, Recharts 3, Vite Web Workers (`new Worker(new URL(...))`), existing tax utilities in `src/lib/tax/`.

---

## Task 1 — Fix Investment Return Decomposition (The Big Engine Bug)

**Files:**
- Modify: `src/lib/accounts/investmentReturns.ts`
- Modify: `src/lib/types.ts` (add optional per-class return rate fields)
- Modify: `src/lib/localStorage.ts` (update defaults)
- Create: `src/lib/__tests__/investmentReturns.test.ts`

### Background

The current bug is in `investmentReturns.ts` line 98:
```typescript
const realizedCapitalGain = totalCapitalGain * 0.5; // 50% realized each year — WRONG
```
This treats half of all annual price appreciation as immediately taxable. For a passive index ETF, actual annual realized capital gains from portfolio turnover are ~0.3–0.4% of the portfolio (near-zero, because ETFs use in-kind creation/redemption). This overstates AAII, causing the SBD grind to trigger far too aggressively.

The correct model: each asset class has empirically-grounded annual income rates derived from historical index data (TSX, S&P 500, MSCI EAFE, CDN Bond Index). Realized capital gains come only from portfolio turnover (~0.3% of balance/yr for equity ETFs, 0% for bonds).

**Research-grounded constants to hardcode:**

| Asset Class | Default Return | Canadian Dividends | Foreign Income | Realized CG (turnover) |
|---|---|---|---|---|
| Canadian Equity (TSX/XIC) | 8.5% | 2.8% of balance | 0% | 0.3% of balance |
| US Equity (S&P 500/VFV) | 9.5% | 0% | 1.5% of balance | 0.3% of balance |
| International (EAFE/XEF) | 7.0% | 0% | 3.0% of balance | 0.4% of balance |
| Fixed Income (CDN Bond/XBB) | 4.0% | 0% | 0% (interest) | 0% |

Unrealized CG = `totalReturn - dividends/income - realizedCG` (not taxed until disposition).

**US withholding tax rule (CRA s.126(1) / s.129(3)):** 15% withholding on US/international dividends is a permanent cost — it reduces the nRDTOH addition: `nRDTOH += (foreignIncome × 0.3067) - (foreignDividends × 0.15)`.

---

### Step 1: Write the failing tests

Create `src/lib/__tests__/investmentReturns.test.ts`:

```typescript
import { describe, it, expect } from 'vitest';
import { calculateInvestmentReturns } from '../accounts/investmentReturns';

const BALANCE = 1_000_000;

describe('calculateInvestmentReturns', () => {
  describe('Canadian equity only (100% TSX)', () => {
    it('realized capital gains are ~0.3% of balance (not 50% of price appreciation)', () => {
      const result = calculateInvestmentReturns(BALANCE, 0.085, 100, 0, 0, 0);
      // Realized CG from turnover: ~0.3% of $1M = ~$3,000
      expect(result.realizedCapitalGain).toBeGreaterThan(2000);
      expect(result.realizedCapitalGain).toBeLessThan(5000);
    });

    it('Canadian dividends are ~2.8% of balance', () => {
      const result = calculateInvestmentReturns(BALANCE, 0.085, 100, 0, 0, 0);
      expect(result.canadianDividends).toBeCloseTo(28000, -3);
    });

    it('zero foreign income', () => {
      const result = calculateInvestmentReturns(BALANCE, 0.085, 100, 0, 0, 0);
      expect(result.foreignIncome).toBe(0);
    });

    it('eRDTOH increases by 38.33% of Canadian dividends', () => {
      const result = calculateInvestmentReturns(BALANCE, 0.085, 100, 0, 0, 0);
      expect(result.eRDTOHIncrease).toBeCloseTo(result.canadianDividends * 0.3833, 0);
    });

    it('CDA increases by 50% of realized capital gains', () => {
      const result = calculateInvestmentReturns(BALANCE, 0.085, 100, 0, 0, 0);
      expect(result.CDAIncrease).toBeCloseTo(result.realizedCapitalGain * 0.5, 0);
    });
  });

  describe('100% fixed income', () => {
    it('zero realized capital gains', () => {
      const result = calculateInvestmentReturns(BALANCE, 0.04, 0, 0, 0, 100);
      expect(result.realizedCapitalGain).toBe(0);
    });

    it('zero Canadian dividends', () => {
      const result = calculateInvestmentReturns(BALANCE, 0.04, 0, 0, 0, 100);
      expect(result.canadianDividends).toBe(0);
    });

    it('all return is foreign income (interest)', () => {
      const result = calculateInvestmentReturns(BALANCE, 0.04, 0, 0, 0, 100);
      // All return is interest; modeled as foreign income for AAII purposes
      expect(result.foreignIncome).toBeGreaterThan(0);
    });
  });

  describe('100% US equity', () => {
    it('foreign income ~1.5% of balance', () => {
      const result = calculateInvestmentReturns(BALANCE, 0.095, 0, 100, 0, 0);
      expect(result.foreignIncome).toBeCloseTo(15000, -3);
    });

    it('zero Canadian dividends', () => {
      const result = calculateInvestmentReturns(BALANCE, 0.095, 0, 100, 0, 0);
      expect(result.canadianDividends).toBe(0);
    });

    it('nRDTOH reduced by 15% withholding on foreign dividends', () => {
      const result = calculateInvestmentReturns(BALANCE, 0.095, 0, 100, 0, 0);
      // nRDTOH = foreignIncome * 0.3067 - foreignDividends * 0.15
      // foreignDividends = 1.5% of balance = 15000
      const expectedNRDTOH = (result.foreignIncome * 0.3067) - (15000 * 0.15);
      expect(result.nRDTOHIncrease).toBeCloseTo(expectedNRDTOH, 0);
    });
  });

  describe('AAII for SBD grind threshold', () => {
    it('60/40 equity/bond portfolio: AAII < $50k (no grind) for $1M corporate balance', () => {
      // 60% equity (mixed), 40% bonds
      const result = calculateInvestmentReturns(BALANCE, 0.072, 20, 20, 20, 40);
      // AAII = foreignIncome + taxableCapGain (50% of realizedCG)
      const aaii = result.foreignIncome + (result.realizedCapitalGain * 0.5);
      // $50k is the grind threshold
      expect(aaii).toBeLessThan(50000);
    });

    it('previously: 100% equity with old 50% realization assumption would have triggered grind', () => {
      // This documents the old (broken) behaviour:
      // old realizedCG = capitalGainRate * 0.5 of total return ≈ huge
      // New behaviour should NOT trigger grind
      const result = calculateInvestmentReturns(BALANCE, 0.085, 60, 20, 20, 0);
      const aaii = result.foreignIncome + (result.realizedCapitalGain * 0.5);
      expect(aaii).toBeLessThan(50000); // grind threshold
    });
  });

  describe('zero balance', () => {
    it('returns all zeros when balance is 0', () => {
      const result = calculateInvestmentReturns(0, 0.06, 33, 33, 34, 0);
      expect(result.totalReturn).toBe(0);
      expect(result.canadianDividends).toBe(0);
      expect(result.foreignIncome).toBe(0);
      expect(result.realizedCapitalGain).toBe(0);
    });
  });
});
```

### Step 2: Run tests — verify they fail

```bash
cd optimal-compensation-calculator && npx vitest run src/lib/__tests__/investmentReturns.test.ts 2>&1 | tail -20
```

Expected: multiple FAIL — `realizedCapitalGain` assertions fail because current code returns ~50% of price appreciation.

### Step 3: Rewrite `calculateInvestmentReturns` in `src/lib/accounts/investmentReturns.ts`

Replace the entire file contents with:

```typescript
import type { InvestmentReturns } from '../types';

// ─── Per-Asset-Class Constants ────────────────────────────────────────────────
// Empirically grounded from historical index data (XIC, VFV/S&P500, XEF/MSCI EAFE, XBB).
// Sources: iShares Canada, Vanguard Canada, PWL Capital, FTSE Russell (2025).

/** Default expected total return per asset class (used to compute blended investmentReturnRate) */
export const ASSET_CLASS_DEFAULT_RETURNS = {
  canadianEquity:      0.085,  // TSX Composite long-run total return
  usEquity:            0.095,  // S&P 500 long-run total return
  internationalEquity: 0.070,  // MSCI EAFE long-run total return
  fixedIncome:         0.040,  // Canadian bond index (yield-based)
} as const;

// Annual income rates as fraction of balance (not of return)
const CANADIAN_EQUITY_DIVIDEND_RATE  = 0.028;  // TSX ~2.8% dividend yield (XIC trailing avg)
const US_EQUITY_FOREIGN_INCOME_RATE  = 0.015;  // S&P 500 ~1.5% dividend yield (2010-2024 avg)
const INTL_EQUITY_FOREIGN_INCOME_RATE = 0.030; // MSCI EAFE ~3.0% dividend yield (XEF/IEFA avg)

// Annual realized capital gains from ETF portfolio turnover (very low for passive index ETFs)
// ETFs use in-kind creation/redemption — negligible capital gains distributions.
const CANADIAN_EQUITY_TURNOVER_CG    = 0.003;  // ~0.3% of balance/yr
const US_EQUITY_TURNOVER_CG          = 0.003;  // ~0.3% of balance/yr
const INTL_EQUITY_TURNOVER_CG        = 0.004;  // ~0.4% of balance/yr (slightly more index churn)
// Fixed income: zero realized CG (bond returns mean-revert to zero price gain over cycle)
const FIXED_INCOME_TURNOVER_CG       = 0.000;

// US/international withholding tax rate on dividends (Canada-US treaty: 15%)
const FOREIGN_WITHHOLDING_RATE = 0.15;

// nRDTOH refundable rate on passive investment income (Part I.3 tax)
const NERDTOH_RATE = 0.3067;

// eRDTOH: Part IV tax on Canadian eligible dividends received (s.186)
const ERDTOH_RATE = 0.3833;

// Capital gains inclusion rate (50% — confirmed current law, proposed 66.67% increase
// was cancelled by the Canadian government on March 21, 2025)
const CG_INCLUSION_RATE = 0.50;

/**
 * Compute the blended investment return rate from per-class allocations and default returns.
 * Call this to populate `investmentReturnRate` when user hasn't overridden it.
 */
export function computeBlendedReturnRate(
  canadianEquityPercent: number,
  usEquityPercent: number,
  internationalEquityPercent: number,
  fixedIncomePercent: number,
  // Optional per-class overrides (from UserInputs advanced fields)
  canadianEquityReturnRate?: number,
  usEquityReturnRate?: number,
  internationalEquityReturnRate?: number,
  fixedIncomeReturnRate?: number,
): number {
  const w = {
    ca:  canadianEquityPercent      / 100,
    us:  usEquityPercent            / 100,
    intl: internationalEquityPercent / 100,
    fi:  fixedIncomePercent         / 100,
  };
  return (
    w.ca   * (canadianEquityReturnRate      ?? ASSET_CLASS_DEFAULT_RETURNS.canadianEquity) +
    w.us   * (usEquityReturnRate            ?? ASSET_CLASS_DEFAULT_RETURNS.usEquity) +
    w.intl * (internationalEquityReturnRate ?? ASSET_CLASS_DEFAULT_RETURNS.internationalEquity) +
    w.fi   * (fixedIncomeReturnRate         ?? ASSET_CLASS_DEFAULT_RETURNS.fixedIncome)
  );
}

/**
 * Calculate investment returns for the corporate account.
 *
 * Uses per-asset-class income rates grounded in historical index data.
 * Realized capital gains are based on ETF portfolio turnover only (~0.3-0.4%/yr),
 * NOT on 50% of annual price appreciation — that was the old (incorrect) approach.
 *
 * Unrealized capital gains are tracked but NOT taxed until disposition (not in AAII).
 * This is correct per ITA: only realized gains are included in aggregate investment income.
 */
export function calculateInvestmentReturns(
  corporateBalance: number,
  returnRate: number = computeBlendedReturnRate(33.33, 33.33, 33.34, 0),
  canadianEquityPercent: number = 33.33,
  usEquityPercent: number = 33.33,
  internationalEquityPercent: number = 33.34,
  fixedIncomePercent: number = 0,
): InvestmentReturns {
  if (corporateBalance <= 0) {
    return {
      totalReturn: 0, canadianDividends: 0, foreignIncome: 0,
      realizedCapitalGain: 0, unrealizedCapitalGain: 0,
      CDAIncrease: 0, nRDTOHIncrease: 0, eRDTOHIncrease: 0, GRIPIncrease: 0,
    };
  }

  const totalReturn = corporateBalance * returnRate;

  const wCA   = canadianEquityPercent      / 100;
  const wUS   = usEquityPercent            / 100;
  const wIntl = internationalEquityPercent / 100;
  const wFI   = fixedIncomePercent         / 100;

  // ── Income from each asset class ────────────────────────────────────────────
  const canadianDividends   = corporateBalance * wCA * CANADIAN_EQUITY_DIVIDEND_RATE;
  const usForeignDividends  = corporateBalance * wUS * US_EQUITY_FOREIGN_INCOME_RATE;
  const intlForeignDividends = corporateBalance * wIntl * INTL_EQUITY_FOREIGN_INCOME_RATE;

  // Fixed income: all return is interest income — treated as foreign/passive income for AAII
  // (interest income is fully included in AAII, same tax treatment as foreign income)
  const interestIncome = corporateBalance * wFI * returnRate;

  const foreignIncome = usForeignDividends + intlForeignDividends + interestIncome;
  const foreignDividends = usForeignDividends + intlForeignDividends; // for withholding calc

  // ── Realized capital gains (turnover-based, NOT price-appreciation-based) ───
  // These are the only gains that are taxable in the current year.
  const realizedCapitalGain =
    corporateBalance * wCA   * CANADIAN_EQUITY_TURNOVER_CG +
    corporateBalance * wUS   * US_EQUITY_TURNOVER_CG +
    corporateBalance * wIntl * INTL_EQUITY_TURNOVER_CG +
    corporateBalance * wFI   * FIXED_INCOME_TURNOVER_CG;

  // ── Unrealized capital gains (price appreciation minus realized) ─────────────
  // These are NOT in AAII — only taxed when the investor disposes of the asset.
  const totalPriceAppreciation = totalReturn - canadianDividends - foreignIncome;
  const unrealizedCapitalGain = Math.max(0, totalPriceAppreciation - realizedCapitalGain);

  // ── Notional account updates ─────────────────────────────────────────────────

  // CDA: 50% of realized capital gains (the non-taxable half flows to CDA, payable tax-free)
  const CDAIncrease = realizedCapitalGain * CG_INCLUSION_RATE;

  // nRDTOH: 30.67% of taxable passive income, REDUCED by foreign withholding tax credit
  // Per s.126(1)/s.129(3): the FTC for withholding reduces the NERDTOH addition —
  // meaning 15% withholding on foreign dividends is a permanent (non-recoverable) cost.
  const taxableCapitalGain = realizedCapitalGain * CG_INCLUSION_RATE;
  const grossNRDTOH = (foreignIncome + taxableCapitalGain) * NERDTOH_RATE;
  const withholdingCredit = foreignDividends * FOREIGN_WITHHOLDING_RATE;
  const nRDTOHIncrease = Math.max(0, grossNRDTOH - withholdingCredit);

  // eRDTOH: 38.33% Part IV tax on Canadian eligible dividends received (s.186)
  // Canadian public company dividends received by CCPC are deductible (s.112) but
  // subject to Part IV tax — fully refundable when eligible dividends paid to shareholders.
  const eRDTOHIncrease = canadianDividends * ERDTOH_RATE;

  // GRIP: eligible dividends received add to GRIP (ITA 89(1)) — allows corp to pay
  // eligible dividends to shareholders, maintaining the eligible dividend character.
  const GRIPIncrease = canadianDividends;

  return {
    totalReturn,
    canadianDividends,
    foreignIncome,
    realizedCapitalGain,
    unrealizedCapitalGain,
    CDAIncrease,
    nRDTOHIncrease,
    eRDTOHIncrease,
    GRIPIncrease,
  };
}
```

### Step 4: Add per-class return overrides to `UserInputs` in `src/lib/types.ts`

After `fixedIncomePercent: number;` (line ~39), add:

```typescript
  // Per-asset-class return rate overrides (optional — defaults to ASSET_CLASS_DEFAULT_RETURNS)
  canadianEquityReturnRate?: number;      // default 0.085
  usEquityReturnRate?: number;            // default 0.095
  internationalEquityReturnRate?: number; // default 0.070
  fixedIncomeReturnRate?: number;         // default 0.040
```

### Step 5: Update `computeBlendedReturnRate` call sites in `calculator.ts`

In `src/lib/calculator.ts`, find the two `calculateInvestmentReturns` calls (lines ~693 and ~1234). Both already pass the 4 allocation percents. No change to the call signature needed — the new defaults are baked into `investmentReturns.ts`.

However, update `investmentReturnRate` default in `getDefaultInputs()` in `src/lib/localStorage.ts`:

```typescript
// Old:
investmentReturnRate: 0.0431,
// New: compute from 33/33/33 equity split with no fixed income
// 0.333 * 0.085 + 0.333 * 0.095 + 0.334 * 0.070 = ~0.0833
// But keep as user-settable; update to a more realistic blended default:
investmentReturnRate: 0.0800,  // ~8% blended (33% CA @ 8.5, 33% US @ 9.5, 34% Intl @ 7.0)
```

Also update the 4 allocation defaults to a more realistic balanced portfolio (current default is 33/33/33/0 — no bonds, which is unusual):

```typescript
canadianEquityPercent: 25,       // was 33.33
usEquityPercent: 25,             // was 33.33
internationalEquityPercent: 25,  // was 33.33
fixedIncomePercent: 25,          // was 0
```

And update `investmentReturnRate` to match the new default allocation:
```typescript
// 0.25*0.085 + 0.25*0.095 + 0.25*0.070 + 0.25*0.040 = 0.0725
investmentReturnRate: 0.0725,
```

### Step 6: Run the tests

```bash
npx vitest run src/lib/__tests__/investmentReturns.test.ts 2>&1 | tail -20
```

Expected: all tests pass.

### Step 7: Run the full suite to catch regressions

```bash
npx vitest run 2>&1 | tail -10
```

Expected: all tests pass. Some numeric assertion tests may need updating if they were hardcoded against the old (wrong) AAII values — update those assertions to reflect the corrected (lower) AAII.

If specific tests fail with changed numbers: open that test file, check the assertion, recalculate with the new model, and update the expected value. Do NOT change the model to match a wrong test — fix the test.

### Step 8: Commit

```bash
git add src/lib/accounts/investmentReturns.ts src/lib/types.ts src/lib/localStorage.ts src/lib/__tests__/investmentReturns.test.ts
git commit -m "fix: per-asset-class return decomposition — realized CG from turnover only, not price appreciation"
```

---

## Task 2 — Monte Carlo: Geometric Mean Fix + Web Worker

**Files:**
- Modify: `src/lib/monteCarlo.ts` (geometric mean fix)
- Create: `src/workers/monteCarlo.worker.ts` (Web Worker)
- Modify: `src/components/tabs/DetailsTab.tsx` (wire up worker)
- Modify: `src/lib/__tests__/monteCarlo.test.ts` (update bias test)

### Step 1: Fix geometric mean bias in `src/lib/monteCarlo.ts`

Find the per-year return sampling loop (around line 74–80):

```typescript
// OLD (arithmetic mean bias):
const perYearReturns = Array.from({ length: years }, () =>
  clamp(
    inputs.investmentReturnRate + randn() * returnStdDev,
    -0.40, 0.60,
  )
);
const meanReturn = perYearReturns.reduce((a, b) => a + b, 0) / years;
```

Replace with:

```typescript
// NEW (geometric mean correction):
// The arithmetic mean of a log-normal distribution overestimates the geometric
// (compounded) return by approximately σ²/2. Correct before sampling so that
// the user's stated return rate is the geometric (real-world compounded) rate,
// not the arithmetic rate. At σ=0.12 this removes ~0.72%/yr optimistic bias.
const geometricMean = inputs.investmentReturnRate - (returnStdDev ** 2) / 2;
const perYearReturns = Array.from({ length: years }, () =>
  clamp(
    geometricMean + randn() * returnStdDev,
    -0.40, 0.60,
  )
);
const meanReturn = perYearReturns.reduce((a, b) => a + b, 0) / years;
```

Also update the comment at line 46–47 from the old bias note to:
```typescript
// Geometric mean correction applied: arithmeticMean - σ²/2 removes the
// ~0.7%/yr log-normal bias. The user's investmentReturnRate is treated as the
// geometric (compounded) return, which is the convention in financial planning.
```

### Step 2: Run monteCarlo tests — still pass

```bash
npx vitest run src/lib/__tests__/monteCarlo.test.ts 2>&1 | tail -10
```

Expected: all 6 tests pass. The `successRate is high for very wealthy scenario` and `successRate is low for underfunded scenario` tests should still hold since the correction is small relative to the extreme wealth differences in those tests.

### Step 3: Create `src/workers/monteCarlo.worker.ts`

```typescript
/**
 * Web Worker for Monte Carlo simulation.
 * Receives UserInputs + MonteCarloOptions via postMessage,
 * returns MonteCarloResult (or null) when complete.
 *
 * Runs in a separate thread so the UI stays responsive during simulation.
 */
import { runMonteCarlo } from '../lib/monteCarlo';
import type { UserInputs } from '../lib/types';
import type { MonteCarloOptions } from '../lib/monteCarlo';

interface WorkerRequest {
  inputs: UserInputs;
  options: MonteCarloOptions;
}

self.onmessage = (event: MessageEvent<WorkerRequest>) => {
  const { inputs, options } = event.data;
  const result = runMonteCarlo(inputs, options);
  self.postMessage(result);
};
```

### Step 4: Update `DetailsTab.tsx` to use the Web Worker

In `src/components/tabs/DetailsTab.tsx`:

Remove from imports:
```typescript
import { runMonteCarlo } from '../../lib/monteCarlo';
```

Keep:
```typescript
import type { MonteCarloResult } from '../../lib/monteCarlo';
```

Replace the `useEffect` block (lines ~31–41):

```typescript
// OLD:
useEffect(() => {
  if (!hasLifetime) {
    setMonteCarloResult(null);
    return;
  }
  const id = setTimeout(() => {
    const result = runMonteCarlo(inputs, { simulationCount: 500 });
    setMonteCarloResult(result);
  }, 0);
  return () => clearTimeout(id);
}, [hasLifetime, inputs]);

// NEW:
useEffect(() => {
  if (!hasLifetime) {
    setMonteCarloResult(null);
    return;
  }
  const worker = new Worker(
    new URL('../../workers/monteCarlo.worker.ts', import.meta.url),
    { type: 'module' }
  );
  worker.onmessage = (event: MessageEvent<MonteCarloResult | null>) => {
    setMonteCarloResult(event.data);
  };
  worker.postMessage({ inputs, options: { simulationCount: 500 } });
  return () => worker.terminate();
}, [hasLifetime, inputs]);
```

### Step 5: TypeScript check

```bash
npx tsc --noEmit 2>&1 | head -20
```

Expected: clean. If worker module resolution errors appear, check that `tsconfig.json` has `"lib": ["ES2020", "DOM", "DOM.Iterable", "WebWorker"]`. If `WebWorker` is missing, add it.

### Step 6: Run full test suite

```bash
npx vitest run 2>&1 | tail -10
```

Expected: all tests pass (workers aren't tested directly in Vitest — the `monteCarlo.ts` logic is tested directly).

### Step 7: Commit

```bash
git add src/lib/monteCarlo.ts src/workers/monteCarlo.worker.ts src/components/tabs/DetailsTab.tsx
git commit -m "feat: Monte Carlo geometric mean fix + Web Worker (non-blocking UI)"
```

---

## Task 3 — Narrative Synthesis Module

**Files:**
- Create: `src/lib/narrativeSynthesis.ts`
- Create: `src/lib/__tests__/narrativeSynthesis.test.ts`

### Step 1: Write failing tests

Create `src/lib/__tests__/narrativeSynthesis.test.ts`:

```typescript
import { describe, it, expect } from 'vitest';
import { buildRecommendationNarrative } from '../narrativeSynthesis';
import type { NarrativeInput } from '../narrativeSynthesis';

function makeNarrativeInput(overrides: Partial<NarrativeInput> = {}): NarrativeInput {
  return {
    winnerId: 'dynamic',
    winnerLabel: 'Dynamic Optimizer',
    runnerId: 'dividends-only',
    runnerLabel: 'Dividends Only',
    lifetimeTaxDifference: 340000,   // winner saves this much vs runner
    estateValueDifference: 180000,   // winner leaves this much more
    rrspRoomDifference: 200000,      // winner builds this much more RRSP room
    annualRetirementIncome: 87400,
    retirementSuccessRate: 0.94,
    objective: 'balanced',
    ...overrides,
  };
}

describe('buildRecommendationNarrative', () => {
  it('returns a non-empty string', () => {
    const result = buildRecommendationNarrative(makeNarrativeInput());
    expect(result).toBeTruthy();
    expect(typeof result).toBe('string');
  });

  it('dynamic winner narrative mentions RRSP room and tax savings', () => {
    const result = buildRecommendationNarrative(makeNarrativeInput({ winnerId: 'dynamic' }));
    expect(result.toLowerCase()).toMatch(/rrsp|tax/);
  });

  it('dividends-only winner narrative mentions estate or structure', () => {
    const result = buildRecommendationNarrative(makeNarrativeInput({
      winnerId: 'dividends-only',
      winnerLabel: 'Dividends Only',
      runnerId: 'dynamic',
      runnerLabel: 'Dynamic Optimizer',
    }));
    expect(result.toLowerCase()).toMatch(/estate|structure|dividend/);
  });

  it('salary-at-ympe winner narrative mentions CPP', () => {
    const result = buildRecommendationNarrative(makeNarrativeInput({
      winnerId: 'salary-at-ympe',
      winnerLabel: 'Salary at YMPE',
      runnerId: 'dynamic',
      runnerLabel: 'Dynamic Optimizer',
    }));
    expect(result.toLowerCase()).toMatch(/cpp|pension|salary/);
  });

  it('includes currency-formatted numbers', () => {
    const result = buildRecommendationNarrative(makeNarrativeInput({
      lifetimeTaxDifference: 340000,
    }));
    // Should contain something like $340,000
    expect(result).toMatch(/\$[\d,]+/);
  });

  it('handles zero differences gracefully (no NaN or undefined)', () => {
    const result = buildRecommendationNarrative(makeNarrativeInput({
      lifetimeTaxDifference: 0,
      estateValueDifference: 0,
      rrspRoomDifference: 0,
    }));
    expect(result).toBeTruthy();
    expect(result).not.toContain('NaN');
    expect(result).not.toContain('undefined');
  });
});
```

### Step 2: Run — verify they fail

```bash
npx vitest run src/lib/__tests__/narrativeSynthesis.test.ts 2>&1 | tail -10
```

Expected: FAIL — module not found.

### Step 3: Create `src/lib/narrativeSynthesis.ts`

```typescript
/**
 * Narrative synthesis for the Recommended tab.
 *
 * Pure functions: given winner/runner data, returns a human-readable explanation
 * of why the winning strategy was chosen. Template strings only — no AI, no
 * external dependencies.
 */

import { formatCurrency } from './formatters';

export interface NarrativeInput {
  winnerId: string;
  winnerLabel: string;
  runnerId: string;
  runnerLabel: string;
  lifetimeTaxDifference: number;    // positive = winner pays less tax
  estateValueDifference: number;    // positive = winner leaves more
  rrspRoomDifference: number;       // positive = winner builds more RRSP room
  annualRetirementIncome: number;
  retirementSuccessRate: number;    // 0–1
  objective: 'maximize-spending' | 'maximize-estate' | 'balanced';
}

/**
 * Build a 1–2 sentence narrative explaining why the winning strategy was chosen.
 */
export function buildRecommendationNarrative(input: NarrativeInput): string {
  const {
    winnerId, winnerLabel, runnerLabel,
    lifetimeTaxDifference, estateValueDifference, rrspRoomDifference,
    annualRetirementIncome, retirementSuccessRate,
  } = input;

  const taxSavings   = Math.abs(lifetimeTaxDifference);
  const estateDiff   = Math.abs(estateValueDifference);
  const rrspDiff     = Math.abs(rrspRoomDifference);
  const successPct   = Math.round(retirementSuccessRate * 100);
  const income       = formatCurrency(annualRetirementIncome);

  if (winnerId === 'dynamic') {
    const parts: string[] = [];
    if (taxSavings > 10000) {
      parts.push(`reduces lifetime tax by ${formatCurrency(taxSavings)} vs. ${runnerLabel}`);
    }
    if (rrspDiff > 10000) {
      parts.push(`builds ${formatCurrency(rrspDiff)} more RRSP room`);
    }
    if (estateDiff > 10000) {
      parts.push(`leaves ${formatCurrency(estateDiff)} more at estate`);
    }
    const reason = parts.length > 0
      ? `${winnerLabel} ${parts.join(' and ')}, by optimizing salary each year to fill RRSP room without triggering higher tax brackets.`
      : `${winnerLabel} produces the best balance of tax efficiency and retirement sustainability for your inputs.`;
    return `${reason} Projected retirement income: ${income}/yr with a ${successPct}% probability of sustaining spending through your planning horizon.`;
  }

  if (winnerId === 'dividends-only') {
    const estateMsg = estateDiff > 10000
      ? `leaves ${formatCurrency(estateDiff)} more at estate than ${runnerLabel}`
      : 'produces the strongest estate outcome for your inputs';
    return `With your corporate balance and investment return, avoiding CPP premiums and RRSP complexity ${estateMsg} — the simpler structure wins here. Projected retirement income: ${income}/yr with a ${successPct}% success rate.`;
  }

  if (winnerId === 'salary-at-ympe') {
    return `Maximizing CPP through a salary at YMPE builds guaranteed, inflation-indexed retirement income that reduces your reliance on corporate drawdown. This produces ${income}/yr in sustainable retirement spending (${successPct}% success rate) while generating ${rrspDiff > 0 ? formatCurrency(rrspDiff) + ' more RRSP room than ' + runnerLabel : 'meaningful RRSP room'}.`;
  }

  // Fallback for custom/current strategy
  return `${winnerLabel} produces ${income}/yr in projected retirement income with a ${successPct}% probability of sustaining your target spending through your planning horizon.`;
}
```

### Step 4: Run tests — verify they pass

```bash
npx vitest run src/lib/__tests__/narrativeSynthesis.test.ts 2>&1 | tail -10
```

Expected: all 6 tests pass.

### Step 5: Commit

```bash
git add src/lib/narrativeSynthesis.ts src/lib/__tests__/narrativeSynthesis.test.ts
git commit -m "feat: narrative synthesis module for recommended tab explanation"
```

---

## Task 4 — Strategy Comparison: Lifetime Winner as Headline + 4th Strategy Slot

**Files:**
- Modify: `src/lib/strategyComparison.ts`
- Modify: `src/lib/__tests__/strategyComparison.test.ts`

### Step 1: Add `isCurrentSetup` flag to `StrategyResult`

In `src/lib/strategyComparison.ts`, add to the `StrategyResult` interface:

```typescript
export interface StrategyResult {
  id: string;
  label: string;
  description: string;
  isCurrentSetup?: boolean;   // true when this slot represents the user's actual current inputs
  summary: ProjectionSummary;
  diff: { ... };
  trueAfterTaxWealth: AfterTaxWealthScenarios;
}
```

### Step 2: Write failing tests

In `src/lib/__tests__/strategyComparison.test.ts`, add a new `describe` block at the bottom:

```typescript
describe('lifetime winner as primary recommendation', () => {
  it('lifetimeWinner.byObjective is defined when planningHorizon >= 20', () => {
    const result = runStrategyComparison(makeInputs({
      planningHorizon: 45,
      currentAge: 45,
      retirementAge: 65,
      planningEndAge: 90,
      retirementSpending: 70000,
      actualRRSPBalance: 200000,
      actualTFSABalance: 100000,
      cppStartAge: 65,
      salaryStartAge: 22,
      averageHistoricalSalary: 60000,
      oasEligible: true,
      oasStartAge: 65,
      lifetimeObjective: 'balanced',
    }));
    expect(result.lifetimeWinner).toBeDefined();
    expect(result.lifetimeWinner!.byObjective).toBeTruthy();
  });
});

describe('4th strategy slot — my current setup', () => {
  it('returns 3 strategies when salaryStrategy is dynamic', () => {
    const result = runStrategyComparison(makeInputs({ salaryStrategy: 'dynamic' }));
    expect(result.strategies).toHaveLength(3);
  });

  it('returns 4 strategies when user has a fixed salary amount set', () => {
    const result = runStrategyComparison(makeInputs({
      salaryStrategy: 'fixed',
      fixedSalaryAmount: 150000,
    }));
    expect(result.strategies).toHaveLength(4);
  });

  it('4th strategy is labelled "My Current Setup" and marked isCurrentSetup', () => {
    const result = runStrategyComparison(makeInputs({
      salaryStrategy: 'fixed',
      fixedSalaryAmount: 150000,
    }));
    const current = result.strategies.find(s => s.isCurrentSetup);
    expect(current).toBeDefined();
    expect(current!.label).toBe('My Current Setup');
  });

  it('current setup salary matches user input', () => {
    const result = runStrategyComparison(makeInputs({
      salaryStrategy: 'fixed',
      fixedSalaryAmount: 150000,
    }));
    const current = result.strategies.find(s => s.isCurrentSetup);
    expect(current).toBeDefined();
    // The current setup should have $150k salary
    const firstYear = current!.summary.yearlyResults[0];
    expect(firstYear.salary).toBeCloseTo(150000, -3);
  });
});
```

### Step 3: Run — verify new tests fail

```bash
npx vitest run src/lib/__tests__/strategyComparison.test.ts 2>&1 | grep -E "FAIL|4th|current|fixed"
```

Expected: the new tests fail (`returns 4 strategies` fails with 3, `isCurrentSetup` is undefined).

### Step 4: Modify `runStrategyComparison` in `src/lib/strategyComparison.ts`

At the top of `runStrategyComparison`, after the `strategyDefs` array definition (after line ~148), add:

```typescript
// If the user has a fixed salary set, add their current setup as a 4th strategy
const hasCustomSetup = inputs.salaryStrategy === 'fixed' && (inputs.fixedSalaryAmount ?? 0) > 0;
if (hasCustomSetup) {
  strategyDefs.unshift({
    id: 'current-setup',
    label: 'My Current Setup',
    description: `Your current salary of ${formatCurrency(inputs.fixedSalaryAmount ?? 0)} — compare against the optimized strategies`,
    inputOverrides: {}, // no overrides — run exactly as user configured
    isCurrentSetup: true,
  });
}
```

Add `isCurrentSetup?: boolean` to the local `strategyDefs` array type:
```typescript
const strategyDefs: Array<{
  id: string;
  label: string;
  description: string;
  inputOverrides: Partial<UserInputs>;
  isCurrentSetup?: boolean;
}> = [...]
```

Then in the `results` mapping (around line 181), pass through `isCurrentSetup`:
```typescript
return {
  id: s.id,
  label: s.label,
  description: s.description,
  isCurrentSetup: s.isCurrentSetup,  // add this line
  summary: s.summary,
  diff: { ... },
  trueAfterTaxWealth: ...,
};
```

Also need `formatCurrency` imported at the top of `strategyComparison.ts` — check if it's already imported; if not:
```typescript
import { formatCurrency } from './formatters';
```

### Step 5: Run — verify tests pass

```bash
npx vitest run src/lib/__tests__/strategyComparison.test.ts 2>&1 | tail -15
```

Expected: all tests pass including the new 4-strategy tests.

### Step 6: Full suite

```bash
npx vitest run 2>&1 | tail -10
```

### Step 7: Commit

```bash
git add src/lib/strategyComparison.ts src/lib/__tests__/strategyComparison.test.ts
git commit -m "feat: 4th strategy slot for user's current setup; lifetime winner as primary signal"
```

---

## Task 5 — Recommended Tab Redesign (Three-Zone Layout)

**Files:**
- Modify: `src/components/tabs/RecommendedTab.tsx`
- Modify: `src/components/tabs/WinnerStrategyCard.tsx`

This is a UI-only change. No new logic — wires up the `lifetimeWinner.byObjective` and `buildRecommendationNarrative` to replace the current `bestOverall`-driven header.

### Step 1: Update `WinnerStrategyCard.tsx`

Replace the winner selection at line 18:

```typescript
// OLD:
const winner = comparison.strategies.find(s => s.id === comparison.winner.bestOverall);

// NEW: prefer lifetime winner when available, fall back to bestOverall
const lifetimeWinnerId = comparison.lifetimeWinner?.byObjective;
const winner = comparison.strategies.find(
  s => s.id === (lifetimeWinnerId ?? comparison.winner.bestOverall)
);
```

Replace the "Why this wins" section (lines 57–121) with a narrative-driven block:

```typescript
import { buildRecommendationNarrative } from '../../lib/narrativeSynthesis';

// Inside the component, after winner and others are defined:
const lt = winner.summary.lifetime;
const runner = others.reduce((best, s) =>
  (s.summary.lifetime?.estateValue ?? 0) > (best.summary.lifetime?.estateValue ?? 0) ? s : best
, others[0]);

const narrative = lt ? buildRecommendationNarrative({
  winnerId: winner.id,
  winnerLabel: winner.label,
  runnerId: runner?.id ?? '',
  runnerLabel: runner?.label ?? '',
  lifetimeTaxDifference: lt.lifetimeTax - (runner?.summary.lifetime?.lifetimeTax ?? lt.lifetimeTax),
  estateValueDifference: lt.estateValue - (runner?.summary.lifetime?.estateValue ?? lt.estateValue),
  rrspRoomDifference: winner.summary.totalRRSPRoomGenerated - (runner?.summary.totalRRSPRoomGenerated ?? 0),
  annualRetirementIncome: lt.totalLifetimeSpending / Math.max(1,
    (winner.summary.yearlyResults.filter(y => y.phase === 'retirement').length)
  ),
  retirementSuccessRate: 0.85, // placeholder until MC result passed in; will wire up in Task 6
  objective: comparison.lifetimeWinner?.objective ?? 'balanced',
}) : null;
```

Replace the "Why this strategy wins" bullet list with:

```tsx
{/* Zone 2 — Why */}
{narrative && (
  <div
    className="mt-4 p-4 rounded-lg text-sm leading-relaxed"
    style={{
      background: 'rgba(255,255,255,0.04)',
      border: '1px solid rgba(255,255,255,0.08)',
      color: 'var(--text-secondary)',
    }}
  >
    {narrative}
  </div>
)}
{!narrative && (
  <div className="mt-4 space-y-1.5 text-sm" style={{ color: 'var(--text-secondary)' }}>
    <div>Total tax: {formatCurrency(winner.summary.totalTax)}</div>
    <div>Final corporate balance: {formatCurrency(winner.summary.finalCorporateBalance)}</div>
    <div>RRSP room generated: {formatCurrency(winner.summary.totalRRSPRoomGenerated)}</div>
  </div>
)}
```

### Step 2: Update `RecommendedTab.tsx` — three-zone layout

Replace line 16 (winner selection):

```typescript
// OLD:
const winner = comparison.strategies.find(s => s.id === comparison.winner.bestOverall);

// NEW:
const lifetimeWinnerId = comparison.lifetimeWinner?.byObjective;
const winner = comparison.strategies.find(
  s => s.id === (lifetimeWinnerId ?? comparison.winner.bestOverall)
);
```

Add Zone 1 headline metrics above `<WinnerStrategyCard>`:

```tsx
{/* Zone 1 — The Answer */}
{winner?.summary.lifetime && (
  <div
    className="glass-card p-5"
    style={{ borderColor: 'rgba(110,231,183,0.3)' }}
  >
    <p className="text-xs font-semibold uppercase tracking-wider mb-3"
       style={{ color: 'var(--text-muted)' }}>
      For your {comparison.lifetimeWinner?.objective ?? 'balanced'} objective
    </p>
    <p className="text-lg font-semibold mb-4" style={{ color: 'var(--text-primary)' }}>
      {winner.label} is your optimal strategy
    </p>
    <div className="grid grid-cols-3 gap-4">
      <div>
        <div className="text-xs mb-1" style={{ color: 'var(--text-muted)' }}>Annual retirement income</div>
        <div className="text-xl font-bold" style={{ color: '#6ee7b7' }}>
          {formatCurrency(
            winner.summary.lifetime.totalLifetimeSpending /
            Math.max(1, winner.summary.yearlyResults.filter(y => y.phase === 'retirement').length)
          )}/yr
        </div>
      </div>
      <div>
        <div className="text-xs mb-1" style={{ color: 'var(--text-muted)' }}>Estate value</div>
        <div className="text-xl font-bold" style={{ color: '#6ee7b7' }}>
          {formatCurrency(winner.summary.lifetime.estateValue)}
        </div>
      </div>
      <div>
        <div className="text-xs mb-1" style={{ color: 'var(--text-muted)' }}>Lifetime effective tax rate</div>
        <div className="text-xl font-bold" style={{ color: '#6ee7b7' }}>
          {formatPercent(winner.summary.lifetime.lifetimeEffectiveRate)}
        </div>
      </div>
    </div>
  </div>
)}
```

Add `formatPercent` import if not already present:
```typescript
import { formatCurrency, formatPercent } from '../../lib/formatters';
```

Wrap existing content in a `Zone 3` label:

```tsx
{/* Zone 3 — Accumulation Phase Details */}
<div>
  <h4 className="text-xs font-semibold uppercase tracking-wider mb-3"
      style={{ color: 'var(--text-muted)' }}>
    Accumulation Phase Details
  </h4>
  <WinnerStrategyCard comparison={comparison} />
  <AfterTaxWealthTable comparison={comparison} />
  <ActionPlanTable yearlyResults={winner.summary.yearlyResults} />
  ...
</div>
```

### Step 3: TypeScript check

```bash
npx tsc --noEmit 2>&1 | head -20
```

Fix any type errors before proceeding.

### Step 4: Visual check — start dev server

```bash
npm run dev
```

Open the app, enter basic inputs, run a comparison, check the Recommended tab. Verify:
- Zone 1 shows retirement income, estate value, tax rate
- WinnerStrategyCard shows narrative text
- Accumulation details still present below

### Step 5: Commit

```bash
git add src/components/tabs/RecommendedTab.tsx src/components/tabs/WinnerStrategyCard.tsx
git commit -m "feat: recommended tab redesign — lifetime outcomes as headline, narrative synthesis"
```

---

## Task 6 — Quick Mode: Per-Section Advanced Toggles

**Files:**
- Modify: `src/components/InputFormClean.tsx`

This is the largest single file change. The form already has `expandedSections` state and a `SectionHeader` component — we're adding a nested "Advanced" toggle inside each section.

### Step 1: Add `advancedOpen` state

In `InputFormClean.tsx`, after the `expandedSections` state (around line 222), add:

```typescript
const [advancedOpen, setAdvancedOpen] = useState<Record<string, boolean>>({
  basic: false,
  accounts: false,
  portfolio: false,
  strategy: false,
  retirement: false,
});

const toggleAdvanced = (section: string) => {
  setAdvancedOpen(prev => ({ ...prev, [section]: !prev[section] }));
};
```

### Step 2: Create `AdvancedToggle` sub-component (inside InputFormClean, before the return)

```typescript
const AdvancedToggle = ({ section }: { section: string }) => (
  <button
    type="button"
    onClick={() => toggleAdvanced(section)}
    className="flex items-center gap-1.5 text-xs mt-3 px-2 py-1 rounded"
    style={{
      color: advancedOpen[section] ? 'var(--text-primary)' : 'var(--text-muted)',
      background: advancedOpen[section] ? 'rgba(255,255,255,0.06)' : 'transparent',
      border: '1px solid rgba(255,255,255,0.08)',
    }}
  >
    <svg
      className={`w-3 h-3 transition-transform duration-150 ${advancedOpen[section] ? 'rotate-180' : ''}`}
      fill="none" viewBox="0 0 24 24" stroke="currentColor" strokeWidth={2}
    >
      <path strokeLinecap="round" strokeLinejoin="round" d="M19 9l-7 7-7-7" />
    </svg>
    {advancedOpen[section] ? 'Hide advanced' : 'Advanced settings'}
  </button>
);
```

### Step 3: Apply to "Basic" section

Find the `expandedSections.basic && (...)` block (around line 320). Inside it, identify the quick inputs (province, required income, current age, retirement age) and the advanced inputs (planning horizon, starting year, target spending, lifetime objective, inflation rate, inflate spending toggle).

Structure:

```tsx
{expandedSections.basic && (
  <div className="space-y-4 pt-2">
    {/* ── Quick inputs — always visible ── */}
    {/* Province selector */}
    {/* Required income */}
    {/* Current age */}
    {/* Retirement age */}

    <AdvancedToggle section="basic" />

    {/* ── Advanced inputs — hidden by default ── */}
    {advancedOpen.basic && (
      <div className="space-y-4 pt-2 border-t" style={{ borderColor: 'rgba(255,255,255,0.06)' }}>
        {/* Planning horizon */}
        {/* Starting year */}
        {/* Target retirement spending */}
        {/* Lifetime objective */}
        {/* Planning end age */}
      </div>
    )}
  </div>
)}
```

### Step 4: Apply to "Accounts" section

Find `expandedSections.balances && (...)`. Quick input: corporate investment balance. Advanced: RRSP balance, TFSA balance, RRSP room, TFSA room, CDA, eRDTOH, nRDTOH, GRIP.

```tsx
{expandedSections.balances && (
  <div className="space-y-4 pt-2">
    {/* Corporate investment balance — always visible */}
    <InputField ... /> {/* corporateInvestmentBalance */}

    <AdvancedToggle section="accounts" />

    {advancedOpen.accounts && (
      <div className="space-y-4 pt-2 border-t" style={{ borderColor: 'rgba(255,255,255,0.06)' }}>
        {/* actualRRSPBalance, actualTFSABalance */}
        {/* rrspBalance (room), tfsaBalance (room) */}
        {/* cdaBalance, eRDTOHBalance, nRDTOHBalance, gripBalance */}
      </div>
    )}
  </div>
)}
```

### Step 5: Apply to "Portfolio" section

Find `expandedSections.portfolio && (...)`. Quick: the 4 allocation sliders (already there). Advanced: per-class return overrides.

First, add a computed blended return display at the end of the quick section:

```tsx
{/* Blended return (read-only, computed from allocation) */}
<div className="text-xs pt-2" style={{ color: 'var(--text-muted)' }}>
  Blended expected return:{' '}
  <span style={{ color: 'var(--text-secondary)', fontWeight: 500 }}>
    {(computeBlendedReturnRate(
      inputs.canadianEquityPercent,
      inputs.usEquityPercent,
      inputs.internationalEquityPercent,
      inputs.fixedIncomePercent,
      inputs.canadianEquityReturnRate,
      inputs.usEquityReturnRate,
      inputs.internationalEquityReturnRate,
      inputs.fixedIncomeReturnRate,
    ) * 100).toFixed(1)}%/yr
  </span>
  {' '}(weighted average of asset class defaults)
</div>
```

Import `computeBlendedReturnRate` from `../../lib/accounts/investmentReturns`.

Then advanced section:

```tsx
<AdvancedToggle section="portfolio" />

{advancedOpen.portfolio && (
  <div className="space-y-4 pt-2 border-t" style={{ borderColor: 'rgba(255,255,255,0.06)' }}>
    <p className="text-xs" style={{ color: 'var(--text-muted)' }}>
      Override expected returns per asset class. Defaults are based on historical index data (TSX, S&P 500, MSCI EAFE, CDN Bond Index).
    </p>
    <PercentInput
      label="Canadian Equity Return"
      value={inputs.canadianEquityReturnRate ?? 0.085}
      onChange={v => handleChange('canadianEquityReturnRate', v)}
    />
    <PercentInput
      label="US Equity Return"
      value={inputs.usEquityReturnRate ?? 0.095}
      onChange={v => handleChange('usEquityReturnRate', v)}
    />
    <PercentInput
      label="International Equity Return"
      value={inputs.internationalEquityReturnRate ?? 0.070}
      onChange={v => handleChange('internationalEquityReturnRate', v)}
    />
    <PercentInput
      label="Fixed Income Return"
      value={inputs.fixedIncomeReturnRate ?? 0.040}
      onChange={v => handleChange('fixedIncomeReturnRate', v)}
    />
    {/* Capital gains inclusion rate — informational only */}
    <div className="text-xs p-3 rounded" style={{ background: 'rgba(255,255,255,0.03)', color: 'var(--text-muted)' }}>
      Capital gains inclusion rate: <strong>50%</strong> (confirmed current law — proposed 66.67% increase was cancelled March 21, 2025)
    </div>
  </div>
)}
```

### Step 6: Apply to "Strategy" section

Find `expandedSections.strategy && (...)`. Currently shows strategy selector + fixed salary. In quick mode, hide the strategy section — default is 'dynamic' (best choice for most users). The advanced toggle reveals the full strategy selector.

Restructure:

```tsx
{expandedSections.strategy && (
  <div className="space-y-4 pt-2">
    <div className="text-sm" style={{ color: 'var(--text-muted)' }}>
      Default: Dynamic Optimizer (engine selects optimal salary each year)
    </div>
    <AdvancedToggle section="strategy" />
    {advancedOpen.strategy && (
      <div className="space-y-4 pt-2 border-t" style={{ borderColor: 'rgba(255,255,255,0.06)' }}>
        {/* Strategy selector: dynamic / fixed / dividends-only */}
        {/* Fixed salary amount (shown only when strategy === 'fixed') */}
      </div>
    )}
  </div>
)}
```

### Step 7: Apply to "Retirement / CPP / OAS" section

Find `expandedSections.retirement` (or whichever section contains CPP/OAS fields). Quick: nothing — these fields are always "advanced" context. Show a brief description of defaults, then advanced toggle.

```tsx
{expandedSections.retirement && (
  <div className="space-y-4 pt-2">
    <div className="text-xs p-3 rounded" style={{ background: 'rgba(255,255,255,0.03)', color: 'var(--text-muted)' }}>
      Defaults: CPP at 65, OAS at 65, 40yr earnings history at $60k/yr. Customize below.
    </div>
    <AdvancedToggle section="retirement" />
    {advancedOpen.retirement && (
      <div className="space-y-4 pt-2 border-t" style={{ borderColor: 'rgba(255,255,255,0.06)' }}>
        {/* CPP start age */}
        {/* Salary start age */}
        {/* Average historical salary */}
        {/* OAS eligible toggle + start age */}
        {/* Actual RRSP balance */}
        {/* Actual TFSA balance */}
        {/* Target retirement spending */}
        {/* Lifetime objective */}
      </div>
    )}
  </div>
)}
```

### Step 8: Wire per-class return rates into `calculateInvestmentReturns` calls in `calculator.ts`

The calculator calls `calculateInvestmentReturns(balance, returnRate, ca%, us%, intl%, fi%)`. The function signature doesn't currently take per-class return overrides. Two options:

**Option A (simpler):** Before the calculator is called, compute `investmentReturnRate` from the allocation + overrides using `computeBlendedReturnRate`. Store it on `UserInputs`. The form does this computation when any allocation or return-override field changes, updating `inputs.investmentReturnRate` live.

**Option B (cleaner):** Pass the 4 optional overrides into `calculateInvestmentReturns`.

Use **Option A** — it requires no changes to `calculator.ts`. In `InputFormClean.tsx`, add a `useEffect` that recomputes `investmentReturnRate` whenever allocation or overrides change:

```typescript
useEffect(() => {
  const blended = computeBlendedReturnRate(
    inputs.canadianEquityPercent,
    inputs.usEquityPercent,
    inputs.internationalEquityPercent,
    inputs.fixedIncomePercent,
    inputs.canadianEquityReturnRate,
    inputs.usEquityReturnRate,
    inputs.internationalEquityReturnRate,
    inputs.fixedIncomeReturnRate,
  );
  // Only update if user hasn't manually overridden investmentReturnRate
  // (if the blended value differs significantly from current, sync it)
  if (Math.abs(blended - inputs.investmentReturnRate) > 0.001) {
    handleChange('investmentReturnRate', blended);
  }
}, [
  inputs.canadianEquityPercent,
  inputs.usEquityPercent,
  inputs.internationalEquityPercent,
  inputs.fixedIncomePercent,
  inputs.canadianEquityReturnRate,
  inputs.usEquityReturnRate,
  inputs.internationalEquityReturnRate,
  inputs.fixedIncomeReturnRate,
]);
```

### Step 9: TypeScript check + dev server visual check

```bash
npx tsc --noEmit 2>&1 | head -20
npm run dev
```

Test:
1. Open app — form should show only quick inputs in each section
2. Click "Advanced settings" in Basic section — extra fields appear
3. Close and reopen — advanced state resets (don't persist — YAGNI)
4. Change portfolio allocation — blended return updates live
5. Override a per-class return — blended return updates

### Step 10: Full test suite

```bash
npx vitest run 2>&1 | tail -10
```

### Step 11: Commit

```bash
git add src/components/InputFormClean.tsx
git commit -m "feat: per-section advanced toggles for quick mode UX"
```

---

## Task 7 — Compare All Tab: Show 4th Strategy When Present

**Files:**
- Modify: `src/components/StrategyComparison.tsx` (the component inside CompareAllTab)

### Step 1: Check current StrategyComparison component

```bash
grep -n "isCurrentSetup\|strategies\|4\|length" src/components/StrategyComparison.tsx | head -20
```

The component maps over `comparison.strategies` — it will already show 4 entries if present. The only change needed is visual differentiation for `isCurrentSetup: true` entries.

### Step 2: Add visual badge to current-setup strategy

In `src/components/StrategyComparison.tsx`, find where each strategy card renders its header/label. Add a conditional badge:

```tsx
{strategy.isCurrentSetup && (
  <span
    className="ml-2 text-xs px-2 py-0.5 rounded-full"
    style={{ background: 'rgba(168,85,247,0.2)', color: '#c084fc' }}
  >
    Your current setup
  </span>
)}
```

Also update the diff display: when `isCurrentSetup` is true, show diffs vs. the lifetime winner (not vs. `bestOverall`):

```tsx
// In the diff section, if the strategy is current-setup, show a callout:
{strategy.isCurrentSetup && (
  <div className="text-xs mt-2 p-2 rounded" style={{ background: 'rgba(255,255,255,0.04)', color: 'var(--text-muted)' }}>
    vs. recommended ({lifetimeWinnerId}): {formatCurrency(Math.abs(strategy.diff.taxSavings))} {strategy.diff.taxSavings < 0 ? 'more' : 'less'} lifetime tax
  </div>
)}
```

### Step 3: TypeScript check + visual verify

```bash
npx tsc --noEmit && npm run dev
```

Test with `salaryStrategy: 'fixed'` and `fixedSalaryAmount: 150000` — should see 4 cards in Compare All.

### Step 4: Full test suite

```bash
npx vitest run 2>&1 | tail -10
```

### Step 5: Commit

```bash
git add src/components/StrategyComparison.tsx
git commit -m "feat: show current setup as 4th strategy in Compare All tab"
```

---

## Final Verification

```bash
npx tsc --noEmit && npx vitest run 2>&1 | tail -10
```

All tests green, no TypeScript errors.

**Manually verify the 6 success criteria from the design doc:**

1. [ ] $1M corp portfolio, 60/40 equity/bonds → AAII < $50k (no SBD grind)
2. [ ] Monte Carlo renders in < 3 seconds (UI stays responsive)
3. [ ] p50 line shifts down vs. old build (geometric mean correction applied)
4. [ ] 4 inputs (province, income, age, corporate balance) → full recommendation, no required advanced fields
5. [ ] Recommended tab headline: retirement income + estate value + tax rate (not tax paid + corporate balance)
6. [ ] Fixed salary user sees 4 strategies in Compare All, with current-setup badge

---

## Notes for Implementer

- `computeBlendedReturnRate` is exported from `investmentReturns.ts` — import it wherever needed
- `buildRecommendationNarrative` is a pure function — pass it the lifetime data directly, no hooks needed
- Workers won't be picked up by Vitest (it tests Node.js environment) — test `monteCarlo.ts` logic directly as before
- The `DetailsTab` currently imports `runMonteCarlo` directly — after Task 2, remove that import entirely (only the worker uses it at runtime)
- `formatCurrency` and `formatPercent` are in `src/lib/formatters.ts`
- `computeBlendedReturnRate` must be imported in `InputFormClean.tsx` from `../../lib/accounts/investmentReturns`
- The `handleChange` function in `InputFormClean.tsx` handles updating `inputs` — check how it's defined before adding the `useEffect` in Task 6 Step 8
