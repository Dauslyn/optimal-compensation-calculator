# v3.4 Form Overhaul Implementation Plan

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.

**Goal:** Replace the single long-form with a wizard-first experience, restructure the full form into logical sections, add multi-debt support with payment frequency, and expand IPP to cover both "considering" and "already have one" modes.

**Architecture:** Five sequential work streams: (1) data model + engine changes (types, calculator, ipp.ts), (2) multi-debt UI, (3) IPP expansion, (4) full form restructure, (5) setup wizard + App.tsx wiring. All changes are additive to UserInputs — backwards compatible with localStorage and share links.

**Tech Stack:** React 19, TypeScript, Vitest, Tailwind CSS v4. No new dependencies required.

---

## CRITICAL CONTEXT

Before starting, read:
- Design doc: `docs/plans/2026-02-19-v3.4-form-overhaul-design.md`
- `src/lib/types.ts` — UserInputs interface (all fields)
- `src/lib/tax/ipp.ts` — existing IPP functions
- `src/lib/localStorage.ts` — getDefaultInputs()
- `src/components/InputFormClean.tsx` — current form structure
- `src/App.tsx` — App layout where wizard gets inserted

Run tests before starting: `cd "/Users/home/Documents/Vibe Coding/Project Ideas/Optimal Compensation Calculator/optimal-compensation-calculator" && npx vitest run` — expect 1,889 passing.

---

## TASK 1: Add DebtEntry type and debts array to UserInputs

**Files:**
- Modify: `src/lib/types.ts`
- Modify: `src/lib/localStorage.ts`

**Context:** Currently UserInputs has scalar debt fields (`payDownDebt`, `totalDebtAmount`, `debtInterestRate`, `debtPaydownAmount`). We replace these with a `debts: DebtEntry[]` array. The scalars stay in UserInputs temporarily for backwards compat with the calculator — we add the array alongside them.

**Step 1: Add DebtEntry interface to types.ts**

In `src/lib/types.ts`, add before the `UserInputs` interface:

```typescript
export type PaymentFrequency = 'weekly' | 'biweekly' | 'semi-monthly' | 'monthly' | 'annually';

export interface DebtEntry {
  id: string;              // uuid for React keys — use crypto.randomUUID() or Date.now().toString()
  label: string;           // e.g. "Mortgage", "Clinic LOC"
  balance: number;         // current outstanding balance
  paymentAmount: number;   // amount per payment period
  paymentFrequency: PaymentFrequency;
  interestRate: number;    // decimal, e.g. 0.055 for 5.5%
}

export const PAYMENT_FREQUENCY_MULTIPLIERS: Record<PaymentFrequency, number> = {
  weekly: 52,
  biweekly: 26,
  'semi-monthly': 24,
  monthly: 12,
  annually: 1,
};

export function aggregateDebts(debts: DebtEntry[]): {
  totalBalance: number;
  totalAnnualPayment: number;
  weightedInterestRate: number;
} {
  if (debts.length === 0) return { totalBalance: 0, totalAnnualPayment: 0, weightedInterestRate: 0 };
  const totalBalance = debts.reduce((s, d) => s + d.balance, 0);
  const totalAnnualPayment = debts.reduce(
    (s, d) => s + d.paymentAmount * PAYMENT_FREQUENCY_MULTIPLIERS[d.paymentFrequency],
    0
  );
  const weightedInterestRate =
    totalBalance > 0
      ? debts.reduce((s, d) => s + d.interestRate * d.balance, 0) / totalBalance
      : 0;
  return { totalBalance, totalAnnualPayment, weightedInterestRate };
}
```

**Step 2: Add `debts` field to UserInputs**

In `src/lib/types.ts`, find the `UserInputs` interface. Add after the existing debt fields (`debtInterestRate?: number`):

```typescript
  // Multi-debt (v3.4+) — replaces scalar debt fields
  debts?: DebtEntry[];
```

**Step 3: Add default for debts in getDefaultInputs()**

In `src/lib/localStorage.ts`, find `getDefaultInputs()`. Add to the returned object:

```typescript
  debts: [],
```

**Step 4: Run tests**

```bash
cd "/Users/home/Documents/Vibe Coding/Project Ideas/Optimal Compensation Calculator/optimal-compensation-calculator" && npx vitest run
```
Expected: 1,889 tests pass (no changes to logic).

**Step 5: TypeScript check**

```bash
npx tsc -p tsconfig.app.json --noEmit 2>&1 | grep -v "ScenarioBuilder\|MonteCarloResults\|boundaryStress\|WinnerStrategyCard\|InputFormClean\|calculator.test\|craPersonalTax\|dollarTrace"
```
Expected: no new errors.

**Step 6: Commit**

```bash
git add src/lib/types.ts src/lib/localStorage.ts
git commit -m "feat: add DebtEntry type, aggregateDebts(), and debts[] to UserInputs"
```

---

## TASK 2: Wire multi-debt aggregation into calculator

**Files:**
- Modify: `src/lib/calculator.ts`

**Context:** The calculator currently reads `inputs.payDownDebt && inputs.debtPaydownAmount` at around line 743. We add a pre-pass that, if `inputs.debts` is non-empty, populates the scalar fields from `aggregateDebts()` so the rest of the calculator works unchanged.

**Step 1: Import aggregateDebts in calculator.ts**

At the top of `src/lib/calculator.ts`, add to the imports from `'./types'`:

```typescript
import type {
  UserInputs,
  // ... existing imports ...
} from './types';
import { aggregateDebts } from './types';
```

**Step 2: Add debt aggregation at start of calculateProjection()**

In `calculateProjection()`, after the function signature and before the first line of logic, add:

```typescript
  // If multi-debt array is present, derive scalar debt fields from it
  if (inputs.debts && inputs.debts.length > 0) {
    const { totalAnnualPayment, totalBalance, weightedInterestRate } = aggregateDebts(inputs.debts);
    inputs = {
      ...inputs,
      payDownDebt: true,
      debtPaydownAmount: totalAnnualPayment,
      totalDebtAmount: totalBalance,
      debtInterestRate: weightedInterestRate,
    };
  }
```

Note: `inputs` parameter needs to be reassignable — change the function signature from `inputs: UserInputs` to `let inputs: UserInputs` (or use a local variable `let effectiveInputs = inputs`).

**Step 3: Write a test**

In `src/lib/__tests__/retirementDrawdown.test.ts` or a new file `src/lib/__tests__/debtAggregation.test.ts`, add:

```typescript
import { describe, it, expect } from 'vitest';
import { aggregateDebts, PAYMENT_FREQUENCY_MULTIPLIERS } from '../types';
import type { DebtEntry } from '../types';

describe('aggregateDebts', () => {
  it('returns zeros for empty array', () => {
    const result = aggregateDebts([]);
    expect(result.totalBalance).toBe(0);
    expect(result.totalAnnualPayment).toBe(0);
    expect(result.weightedInterestRate).toBe(0);
  });

  it('computes annual payment from monthly frequency', () => {
    const debts: DebtEntry[] = [{
      id: '1',
      label: 'Mortgage',
      balance: 400000,
      paymentAmount: 2000,
      paymentFrequency: 'monthly',
      interestRate: 0.05,
    }];
    const result = aggregateDebts(debts);
    expect(result.totalAnnualPayment).toBe(24000); // 2000 × 12
    expect(result.totalBalance).toBe(400000);
    expect(result.weightedInterestRate).toBeCloseTo(0.05);
  });

  it('computes balance-weighted interest rate across multiple debts', () => {
    const debts: DebtEntry[] = [
      { id: '1', label: 'Mortgage', balance: 400000, paymentAmount: 2000, paymentFrequency: 'monthly', interestRate: 0.05 },
      { id: '2', label: 'LOC', balance: 100000, paymentAmount: 500, paymentFrequency: 'monthly', interestRate: 0.07 },
    ];
    const result = aggregateDebts(debts);
    // Weighted: (400000×0.05 + 100000×0.07) / 500000 = (20000 + 7000) / 500000 = 0.054
    expect(result.weightedInterestRate).toBeCloseTo(0.054);
    expect(result.totalBalance).toBe(500000);
    expect(result.totalAnnualPayment).toBe(30000); // (2000 + 500) × 12
  });

  it('handles biweekly frequency correctly', () => {
    const debts: DebtEntry[] = [{
      id: '1', label: 'Mortgage', balance: 300000,
      paymentAmount: 1200, paymentFrequency: 'biweekly', interestRate: 0.05,
    }];
    expect(aggregateDebts(debts).totalAnnualPayment).toBe(1200 * 26);
  });
});
```

**Step 4: Run test to confirm it passes**

```bash
npx vitest run src/lib/__tests__/debtAggregation.test.ts
```
Expected: 4 tests pass.

**Step 5: Run full suite**

```bash
npx vitest run
```
Expected: 1,893+ tests pass.

**Step 6: Commit**

```bash
git add src/lib/calculator.ts src/lib/__tests__/debtAggregation.test.ts
git commit -m "feat: wire multi-debt aggregation into calculator — debts[] drives debt scalars"
```

---

## TASK 3: Add IPP "existing fund" fields to UserInputs and expand ipp.ts

**Files:**
- Modify: `src/lib/types.ts`
- Modify: `src/lib/tax/ipp.ts`
- Modify: `src/lib/localStorage.ts`

**Context:** We need new UserInputs fields for the "already have one" IPP mode, and new exported functions in ipp.ts for the calculations the design calls for.

**Step 1: Add IPP fields to UserInputs**

In `src/lib/types.ts`, find the IPP fields block:

```typescript
  // IPP
  considerIPP?: boolean;
  ippMemberAge?: number;
  ippYearsOfService?: number;
```

Add after `ippYearsOfService`:

```typescript
  // IPP v3.4 — expanded fields
  ippMode?: 'considering' | 'existing';           // default: 'considering'
  ippBest3AvgSalary?: number;                     // defaults to requiredIncome if unset
  ippPastServiceYears?: number;                   // years credited before IPP was set up
  ippExistingFundBalance?: number;                // current FMV of fund (existing mode only)
  ippLastValuationYear?: number;                  // year of last actuarial valuation
  ippLastValuationLiability?: number;             // actuarial liability from last report ($)
  ippLastValuationAnnualContribution?: number;    // annual CSC from last report ($)
```

Do the same for the spouse IPP block, adding after `spouseIPPYearsOfService`:

```typescript
  spouseIPPMode?: 'considering' | 'existing';
  spouseIPPBest3AvgSalary?: number;
  spouseIPPPastServiceYears?: number;
  spouseIPPExistingFundBalance?: number;
  spouseIPPLastValuationYear?: number;
  spouseIPPLastValuationLiability?: number;
  spouseIPPLastValuationAnnualContribution?: number;
```

**Step 2: Add new IPP engine functions to ipp.ts**

In `src/lib/tax/ipp.ts`, add these exports at the bottom of the file:

```typescript
// Annuity factor at retirement age 65 using 1983 GAM with 3% post-retirement indexing
// This is a CRA-prescribed approximation for planning purposes
const ANNUITY_FACTOR_AT_65 = 12.5;
const PRESCRIBED_DISCOUNT_RATE = 0.075; // ITA Reg 8515

/**
 * Calculate projected annual pension at retirement.
 * Formula: min(2% × best3AvgSalary, DB_limit_at_retirement) × totalYearsOfService
 * Source: ITA Regulation 8504
 */
export function calculateProjectedPension(
  totalYearsOfService: number,
  best3AvgSalary: number,
  retirementYear: number,
): number {
  const dbLimit =
    IPP_LIMITS[retirementYear]?.maxPensionableBenefit ??
    IPP_LIMITS[2026].maxPensionableBenefit;
  const unitPension = Math.min(0.02 * best3AvgSalary, dbLimit);
  return unitPension * totalYearsOfService;
}

/**
 * Estimate the current actuarial target liability by rolling forward
 * from the last triennial valuation using the prescribed 7.5% discount rate.
 * Between-valuation estimate only — not a formal actuarial valuation.
 * Source: ITA Reg 8515; Projected Unit Credit method
 */
export function estimateCurrentTargetLiability(
  lastValuationLiability: number,
  lastValuationYear: number,
  annualCSC: number,
  currentYear: number,
): number {
  const yearsElapsed = Math.max(0, currentYear - lastValuationYear);
  // Liability grows at prescribed 7.5% (unwinding of discount)
  const liabilityGrown = lastValuationLiability * Math.pow(1 + PRESCRIBED_DISCOUNT_RATE, yearsElapsed);
  // Add CSC contributions accumulated at 7.5%
  const cscAccumulated =
    yearsElapsed > 0
      ? annualCSC * ((Math.pow(1 + PRESCRIBED_DISCOUNT_RATE, yearsElapsed) - 1) / PRESCRIBED_DISCOUNT_RATE)
      : 0;
  return liabilityGrown + cscAccumulated;
}

export interface FundingStatus {
  estimatedTargetLiability: number;
  currentFundFMV: number;
  gap: number;               // positive = deficiency (need more contributions)
  surplus: number;           // positive = surplus
  fundingRatio: number;      // fund / liability
  contributionHolidayTriggered: boolean; // fund > 1.25× liability (ITA s.147.2(2)(d))
  deficiencyLikely: boolean; // gap > 0 and approaching next valuation
}

/**
 * Calculate current funding status of an existing IPP.
 */
export function calculateFundingStatus(
  currentFundFMV: number,
  estimatedTargetLiability: number,
): FundingStatus {
  const gap = Math.max(0, estimatedTargetLiability - currentFundFMV);
  const surplus = Math.max(0, currentFundFMV - estimatedTargetLiability);
  const fundingRatio = estimatedTargetLiability > 0 ? currentFundFMV / estimatedTargetLiability : 1;
  return {
    estimatedTargetLiability,
    currentFundFMV,
    gap,
    surplus,
    fundingRatio,
    contributionHolidayTriggered: currentFundFMV > estimatedTargetLiability * 1.25,
    deficiencyLikely: gap > 0,
  };
}

/**
 * Estimate terminal funding room available at retirement.
 * This is the additional deductible lump-sum the corporation can contribute
 * at pension commencement to bridge fund shortfall to annuity cost.
 * Positive = additional room (most cases). Negative = overfunded (rare).
 */
export function estimateTerminalFunding(
  projectedFundAtRetirement: number,
  projectedAnnualPension: number,
): number {
  const annuityCost = projectedAnnualPension * ANNUITY_FACTOR_AT_65;
  return Math.max(0, annuityCost - projectedFundAtRetirement);
}
```

**Step 3: Write tests for new IPP functions**

Create `src/lib/__tests__/ippExpanded.test.ts`:

```typescript
import { describe, it, expect } from 'vitest';
import {
  calculateProjectedPension,
  estimateCurrentTargetLiability,
  calculateFundingStatus,
  estimateTerminalFunding,
} from '../tax/ipp';

describe('calculateProjectedPension', () => {
  it('caps pension at DB limit when salary exceeds implied cap', () => {
    // DB limit 2026 = 3725. Implied salary cap = 3725 / 0.02 = 186,250.
    // Salary $250,000 exceeds cap, so unit pension = $3,725.
    const pension = calculateProjectedPension(20, 250000, 2026);
    expect(pension).toBeCloseTo(3725 * 20); // $74,500
  });

  it('uses actual salary when below DB limit cap', () => {
    // 2% × $150,000 = $3,000 < $3,725 DB limit
    const pension = calculateProjectedPension(20, 150000, 2026);
    expect(pension).toBeCloseTo(0.02 * 150000 * 20); // $60,000
  });

  it('falls back to 2026 limit for unknown future year', () => {
    const p2030 = calculateProjectedPension(10, 200000, 2030);
    const p2026 = calculateProjectedPension(10, 200000, 2026);
    expect(p2030).toBe(p2026);
  });
});

describe('estimateCurrentTargetLiability', () => {
  it('returns liability grown at 7.5% with no CSC', () => {
    // $500,000 liability, 3 years ago, $0 CSC
    const result = estimateCurrentTargetLiability(500000, 2022, 0, 2025);
    expect(result).toBeCloseTo(500000 * Math.pow(1.075, 3));
  });

  it('adds CSC contributions accumulated at 7.5%', () => {
    const result = estimateCurrentTargetLiability(500000, 2023, 36000, 2025);
    const liabilityGrown = 500000 * Math.pow(1.075, 2);
    // CSC accumulated: 36000 × ((1.075^2 - 1) / 0.075)
    const cscAccum = 36000 * ((Math.pow(1.075, 2) - 1) / 0.075);
    expect(result).toBeCloseTo(liabilityGrown + cscAccum);
  });

  it('returns liability unchanged when years elapsed = 0', () => {
    const result = estimateCurrentTargetLiability(500000, 2025, 36000, 2025);
    expect(result).toBeCloseTo(500000);
  });
});

describe('calculateFundingStatus', () => {
  it('shows deficiency when fund < liability', () => {
    const status = calculateFundingStatus(450000, 550000);
    expect(status.gap).toBeCloseTo(100000);
    expect(status.surplus).toBe(0);
    expect(status.deficiencyLikely).toBe(true);
    expect(status.contributionHolidayTriggered).toBe(false);
    expect(status.fundingRatio).toBeCloseTo(450000 / 550000);
  });

  it('shows surplus when fund > liability', () => {
    const status = calculateFundingStatus(600000, 500000);
    expect(status.surplus).toBeCloseTo(100000);
    expect(status.gap).toBe(0);
    expect(status.deficiencyLikely).toBe(false);
  });

  it('triggers contribution holiday when fund > 1.25× liability', () => {
    const status = calculateFundingStatus(650000, 500000);
    expect(status.contributionHolidayTriggered).toBe(true);
  });
});

describe('estimateTerminalFunding', () => {
  it('returns positive value when fund < annuity cost', () => {
    // Annual pension $70,000, annuity factor 12.5 → cost = $875,000
    // Fund $600,000 → gap = $275,000
    const result = estimateTerminalFunding(600000, 70000);
    expect(result).toBeCloseTo(875000 - 600000);
  });

  it('returns zero when fund >= annuity cost', () => {
    const result = estimateTerminalFunding(1000000, 70000);
    expect(result).toBe(0);
  });
});
```

**Step 4: Run tests**

```bash
npx vitest run src/lib/__tests__/ippExpanded.test.ts
```
Expected: all tests pass.

**Step 5: Update getDefaultInputs() for new IPP fields**

In `src/lib/localStorage.ts`, in `getDefaultInputs()`, the new optional fields don't need defaults (they're `?:` optional) but add:

```typescript
  ippMode: 'considering',
```

**Step 6: Run full suite**

```bash
npx vitest run
```
Expected: 1,900+ tests pass.

**Step 7: Commit**

```bash
git add src/lib/types.ts src/lib/tax/ipp.ts src/lib/localStorage.ts src/lib/__tests__/ippExpanded.test.ts
git commit -m "feat: IPP expanded — existing fund mode fields, calculateProjectedPension, estimateCurrentTargetLiability, calculateFundingStatus, estimateTerminalFunding"
```

---

## TASK 4: Update share link serialization for new fields

**Files:**
- Modify: `src/lib/shareLink.ts`

**Context:** Share links use a compact key mapping. We need to add compact keys for: `debts[]` array, and the 7 new IPP fields. Old share links without these keys just get undefined → defaults (backwards compatible).

**Step 1: Add new compact keys to CompactInputs interface**

In `src/lib/shareLink.ts`, in the `CompactInputs` interface, add:

```typescript
  // Multi-debt (v3.4)
  dts?: Array<{         // debts array
    id: string;
    lb: string;         // label
    bl: number;         // balance
    pa: number;         // paymentAmount
    pf: string;         // paymentFrequency
    ir: number;         // interestRate
  }>;

  // IPP expanded (v3.4)
  im?: string;          // ippMode
  ib3?: number;         // ippBest3AvgSalary
  ips?: number;         // ippPastServiceYears
  ief?: number;         // ippExistingFundBalance
  ilvy?: number;        // ippLastValuationYear
  ilvl?: number;        // ippLastValuationLiability
  ilvc?: number;        // ippLastValuationAnnualContribution
  // Spouse IPP expanded
  sim?: string;         // spouseIPPMode
  sib3?: number;
  sips?: number;
  sief?: number;
  silvy?: number;
  silvl?: number;
  silvc?: number;
```

**Step 2: Add serialization in compressInputs()**

In the `compressInputs()` function, add after the existing IPP fields:

```typescript
  // Multi-debt
  if (inputs.debts && inputs.debts.length > 0) {
    compact.dts = inputs.debts.map(d => ({
      id: d.id,
      lb: d.label,
      bl: d.balance,
      pa: d.paymentAmount,
      pf: d.paymentFrequency,
      ir: d.interestRate,
    }));
  }

  // IPP expanded
  if (inputs.ippMode) compact.im = inputs.ippMode;
  if (inputs.ippBest3AvgSalary !== undefined) compact.ib3 = inputs.ippBest3AvgSalary;
  if (inputs.ippPastServiceYears !== undefined) compact.ips = inputs.ippPastServiceYears;
  if (inputs.ippExistingFundBalance !== undefined) compact.ief = inputs.ippExistingFundBalance;
  if (inputs.ippLastValuationYear !== undefined) compact.ilvy = inputs.ippLastValuationYear;
  if (inputs.ippLastValuationLiability !== undefined) compact.ilvl = inputs.ippLastValuationLiability;
  if (inputs.ippLastValuationAnnualContribution !== undefined) compact.ilvc = inputs.ippLastValuationAnnualContribution;
```

**Step 3: Add deserialization in expandInputs()**

In the `expandInputs()` function (or wherever CompactInputs maps back to UserInputs), add:

```typescript
  // Multi-debt
  debts: compact.dts
    ? compact.dts.map(d => ({
        id: d.id,
        label: d.lb,
        balance: d.bl,
        paymentAmount: d.pa,
        paymentFrequency: d.pf as PaymentFrequency,
        interestRate: d.ir,
      }))
    : [],

  // IPP expanded
  ippMode: (compact.im as 'considering' | 'existing') ?? 'considering',
  ippBest3AvgSalary: compact.ib3,
  ippPastServiceYears: compact.ips,
  ippExistingFundBalance: compact.ief,
  ippLastValuationYear: compact.ilvy,
  ippLastValuationLiability: compact.ilvl,
  ippLastValuationAnnualContribution: compact.ilvc,
```

You'll also need to import `PaymentFrequency` at the top of `shareLink.ts`:
```typescript
import type { PaymentFrequency, DebtEntry } from './types';
```

**Step 4: Run tests**

```bash
npx vitest run
```
Expected: all tests pass.

**Step 5: Commit**

```bash
git add src/lib/shareLink.ts
git commit -m "feat: shareLink — serialize/deserialize debts array and IPP expanded fields"
```

---

## TASK 5: Multi-debt UI in InputFormClean

**Files:**
- Modify: `src/components/InputFormClean.tsx`

**Context:** Replace the current single-debt block (the `debt` expandedSection) with a multi-debt UI. The debt section header stays collapsible. Inside, show a list of DebtEntry rows with add/remove.

**Step 1: Add debt row helpers to InputFormClean**

Near the top of `InputFormClean.tsx` (after imports), add:

```typescript
import type { DebtEntry, PaymentFrequency } from '../lib/types';
import { PAYMENT_FREQUENCY_MULTIPLIERS } from '../lib/types';

const FREQUENCY_LABELS: Record<PaymentFrequency, string> = {
  weekly: 'Weekly',
  biweekly: 'Bi-weekly',
  'semi-monthly': 'Semi-monthly (2×/month)',
  monthly: 'Monthly',
  annually: 'Annually',
};

function makeDebtId() {
  return typeof crypto !== 'undefined' && crypto.randomUUID
    ? crypto.randomUUID()
    : Date.now().toString();
}
```

**Step 2: Replace debt section in the form JSX**

Find the current debt section (search for `expandedSections.debt` or "Include Debt Payments"). Replace the entire debt section JSX with:

```tsx
{/* Debt Management */}
<div className="p-4 rounded-xl" style={{ background: 'var(--bg-elevated)', border: '1px solid var(--border-subtle)' }}>
  <SectionHeader
    title="Debt Management"
    section="debt"
    description={
      formData.debts && formData.debts.length > 0
        ? `${formData.debts.length} debt${formData.debts.length > 1 ? 's' : ''} — $${Math.round(
            formData.debts.reduce((s, d) => s + d.paymentAmount * PAYMENT_FREQUENCY_MULTIPLIERS[d.paymentFrequency], 0)
          ).toLocaleString()}/yr in payments`
        : 'Add debts to model paydown in your plan'
    }
  />

  {expandedSections.debt && (
    <div className="pt-4 mt-2 animate-fade-in space-y-4" style={{ borderTop: '1px solid var(--border-subtle)' }}>
      {/* Debt rows */}
      {(formData.debts ?? []).map((debt, idx) => (
        <div key={debt.id} className="p-3 rounded-lg space-y-3" style={{ background: 'var(--bg-base)', border: '1px solid var(--border-subtle)' }}>
          <div className="flex items-center justify-between">
            <span className="text-sm font-medium" style={{ color: 'var(--text-primary)' }}>
              Debt {idx + 1}
            </span>
            <button
              type="button"
              onClick={() =>
                setFormData(prev => ({
                  ...prev,
                  debts: (prev.debts ?? []).filter(d => d.id !== debt.id),
                }))
              }
              className="text-xs px-2 py-1 rounded"
              style={{ color: 'var(--text-dim)', background: 'var(--bg-elevated)' }}
            >
              Remove
            </button>
          </div>
          <div className="grid grid-cols-1 md:grid-cols-2 gap-3">
            <div>
              <label className="block text-xs font-medium mb-1" style={{ color: 'var(--text-secondary)' }}>Label</label>
              <input
                type="text"
                value={debt.label}
                onChange={e => setFormData(prev => ({
                  ...prev,
                  debts: (prev.debts ?? []).map(d => d.id === debt.id ? { ...d, label: e.target.value } : d),
                }))}
                placeholder="e.g. Mortgage, Clinic LOC"
                className="w-full px-3 py-2 rounded-lg text-sm"
                style={{ background: 'var(--bg-input)', border: '1px solid var(--border-default)', color: 'var(--text-primary)' }}
              />
            </div>
            <div>
              <label className="block text-xs font-medium mb-1" style={{ color: 'var(--text-secondary)' }}>Outstanding Balance</label>
              <div className="relative">
                <span className="absolute left-3 top-1/2 -translate-y-1/2 text-sm" style={{ color: 'var(--text-dim)' }}>$</span>
                <input
                  type="text"
                  inputMode="decimal"
                  value={debt.balance === 0 ? '' : debt.balance}
                  onChange={e => {
                    const v = parseFloat(e.target.value);
                    setFormData(prev => ({
                      ...prev,
                      debts: (prev.debts ?? []).map(d => d.id === debt.id ? { ...d, balance: isNaN(v) ? 0 : v } : d),
                    }));
                  }}
                  placeholder="450000"
                  className="w-full pl-7 pr-3 py-2 rounded-lg text-sm"
                  style={{ background: 'var(--bg-input)', border: '1px solid var(--border-default)', color: 'var(--text-primary)' }}
                />
              </div>
            </div>
            <div>
              <label className="block text-xs font-medium mb-1" style={{ color: 'var(--text-secondary)' }}>Payment Amount</label>
              <div className="relative">
                <span className="absolute left-3 top-1/2 -translate-y-1/2 text-sm" style={{ color: 'var(--text-dim)' }}>$</span>
                <input
                  type="text"
                  inputMode="decimal"
                  value={debt.paymentAmount === 0 ? '' : debt.paymentAmount}
                  onChange={e => {
                    const v = parseFloat(e.target.value);
                    setFormData(prev => ({
                      ...prev,
                      debts: (prev.debts ?? []).map(d => d.id === debt.id ? { ...d, paymentAmount: isNaN(v) ? 0 : v } : d),
                    }));
                  }}
                  placeholder="2800"
                  className="w-full pl-7 pr-3 py-2 rounded-lg text-sm"
                  style={{ background: 'var(--bg-input)', border: '1px solid var(--border-default)', color: 'var(--text-primary)' }}
                />
              </div>
            </div>
            <div>
              <label className="block text-xs font-medium mb-1" style={{ color: 'var(--text-secondary)' }}>Frequency</label>
              <select
                value={debt.paymentFrequency}
                onChange={e => setFormData(prev => ({
                  ...prev,
                  debts: (prev.debts ?? []).map(d => d.id === debt.id ? { ...d, paymentFrequency: e.target.value as PaymentFrequency } : d),
                }))}
                className="w-full px-3 py-2 rounded-lg text-sm"
                style={{ background: 'var(--bg-input)', border: '1px solid var(--border-default)', color: 'var(--text-primary)' }}
              >
                {(Object.keys(FREQUENCY_LABELS) as PaymentFrequency[]).map(f => (
                  <option key={f} value={f}>{FREQUENCY_LABELS[f]}</option>
                ))}
              </select>
            </div>
            <div>
              <label className="block text-xs font-medium mb-1" style={{ color: 'var(--text-secondary)' }}>Interest Rate</label>
              <div className="relative">
                <input
                  type="text"
                  inputMode="decimal"
                  value={debt.interestRate === 0 ? '' : (debt.interestRate * 100).toPrecision(4).replace(/\.?0+$/, '')}
                  onChange={e => {
                    const v = parseFloat(e.target.value);
                    setFormData(prev => ({
                      ...prev,
                      debts: (prev.debts ?? []).map(d => d.id === debt.id ? { ...d, interestRate: isNaN(v) ? 0 : v / 100 } : d),
                    }));
                  }}
                  placeholder="5.5"
                  className="w-full pr-8 pl-3 py-2 rounded-lg text-sm"
                  style={{ background: 'var(--bg-input)', border: '1px solid var(--border-default)', color: 'var(--text-primary)' }}
                />
                <span className="absolute right-3 top-1/2 -translate-y-1/2 text-sm" style={{ color: 'var(--text-dim)' }}>%</span>
              </div>
            </div>
          </div>
        </div>
      ))}

      {/* Add debt button */}
      <button
        type="button"
        onClick={() =>
          setFormData(prev => ({
            ...prev,
            debts: [
              ...(prev.debts ?? []),
              {
                id: makeDebtId(),
                label: '',
                balance: 0,
                paymentAmount: 0,
                paymentFrequency: 'monthly',
                interestRate: 0.055,
              },
            ],
          }))
        }
        className="w-full py-2 rounded-lg text-sm font-medium border-dashed border-2 transition-colors"
        style={{ borderColor: 'var(--border-default)', color: 'var(--text-secondary)', background: 'transparent' }}
      >
        + Add a debt
      </button>
    </div>
  )}
</div>
```

**Step 3: Remove old single-debt fields from handleSubmit / form state propagation**

The form's `formData` state is type `UserInputs`. Since we've added `debts?: DebtEntry[]`, it's already there. Ensure the submit handler passes `formData` (including `debts`) directly to `onCalculate` — no changes needed if it already does `onCalculate(formData)`.

The old `payDownDebt`, `totalDebtAmount`, `debtInterestRate`, `debtPaydownAmount` fields can stay in UserInputs for backwards compat — they'll be ignored by the calculator if `debts` is non-empty (handled in Task 2).

**Step 4: Start dev server and manually verify**

```bash
npm run dev
```

Open http://localhost:5173/optimal-compensation-calculator/. Expand the Debt Management section. Verify:
- "Add a debt" button appears
- Adding a debt shows a row with all 5 fields
- Frequency dropdown shows all 5 options
- Removing a debt removes the row
- Section description updates to show count and annual payment total

**Step 5: Run full test suite**

```bash
npx vitest run
```
Expected: all tests pass.

**Step 6: Commit**

```bash
git add src/components/InputFormClean.tsx
git commit -m "feat: multi-debt UI with add/remove rows, payment frequency dropdown"
```

---

## TASK 6: IPP section expansion in InputFormClean

**Files:**
- Modify: `src/components/InputFormClean.tsx`
- Modify: `src/components/Tooltip.tsx` (add IPP tooltip strings)

**Context:** Expand the IPP section to show two modes: "Considering" (existing fields + engine outputs) and "Already have one" (new fields + funding status outputs). Output cards are read-only display panels computed from ipp.ts functions.

**Step 1: Add IPP tooltip strings**

In `src/components/Tooltip.tsx`, in the `INPUT_TOOLTIPS` object, add:

```typescript
  ippMode: 'Select whether you are evaluating starting an IPP or already have one established.',
  ippBest3AvgSalary: 'Your 3 highest years of T4 employment income, averaged. Used to calculate your maximum pension entitlement. Leave blank to use your current required income as a proxy.',
  ippPastServiceYears: 'Years of employment by your corporation before the IPP was set up. Past service recognized at inception increases your pension entitlement.',
  ippExistingFundBalance: 'Current fair market value of your IPP investment fund. Found on your most recent investment statement.',
  ippLastValuationYear: 'The year of your most recent formal actuarial valuation report. CRA requires a valuation at least every 3 years.',
  ippLastValuationLiability: 'The actuarial liability (target funding amount) from your most recent valuation report. Your actuary calculates this.',
  ippLastValuationAnnualContribution: 'The recommended annual current service cost from your most recent valuation report.',
```

**Step 2: Replace IPP section JSX**

Find the current IPP section in `InputFormClean.tsx` (search for `expandedSections.ipp`). Replace the entire section content (the part inside `expandedSections.ipp &&`) with:

```tsx
{expandedSections.ipp && (
  <div className="pt-4 mt-2 animate-fade-in space-y-4" style={{ borderTop: '1px solid var(--border-subtle)' }}>
    {/* Include IPP toggle */}
    <label className="flex items-center gap-2 cursor-pointer text-sm font-medium" style={{ color: 'var(--text-secondary)' }}>
      <input
        type="checkbox"
        checked={formData.considerIPP ?? false}
        onChange={e => setFormData({ ...formData, considerIPP: e.target.checked })}
        className="w-4 h-4 rounded"
      />
      <span>Include IPP Analysis</span>
    </label>

    {formData.considerIPP && (
      <div className="space-y-4">
        {/* Mode toggle */}
        <div>
          <InfoLabel label="IPP Status" tooltip={INPUT_TOOLTIPS.ippMode} htmlFor="ippMode" />
          <select
            id="ippMode"
            value={formData.ippMode ?? 'considering'}
            onChange={e => setFormData({ ...formData, ippMode: e.target.value as 'considering' | 'existing' })}
            className="mt-1 w-full px-3 py-2 rounded-lg text-sm"
            style={{ background: 'var(--bg-input)', border: '1px solid var(--border-default)', color: 'var(--text-primary)' }}
          >
            <option value="considering">Considering starting an IPP</option>
            <option value="existing">Already have an IPP</option>
          </select>
        </div>

        {/* Common fields */}
        <div className="grid grid-cols-1 md:grid-cols-3 gap-4">
          <InputField
            label="Your Age"
            id="ippMemberAge"
            value={formData.ippMemberAge || formData.currentAge}
            onChange={v => handleNumberChange('ippMemberAge', v)}
            tooltip={INPUT_TOOLTIPS.ippAge}
          />
          <InputField
            label="Years of Service"
            id="ippYearsOfService"
            value={formData.ippYearsOfService || ''}
            onChange={v => handleNumberChange('ippYearsOfService', v)}
            tooltip={INPUT_TOOLTIPS.ippYearsOfService}
            hint="Years employed by your corporation"
          />
          <InputField
            label="Best 3-Year Avg T4 Salary"
            id="ippBest3AvgSalary"
            value={formData.ippBest3AvgSalary || ''}
            onChange={v => handleNumberChange('ippBest3AvgSalary', v)}
            tooltip={INPUT_TOOLTIPS.ippBest3AvgSalary}
            prefix="$"
            placeholder={String(formData.requiredIncome)}
          />
        </div>

        {/* Existing IPP fields */}
        {(formData.ippMode ?? 'considering') === 'existing' && (
          <div className="space-y-4">
            <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
              <InputField
                label="Past Service Years Credited"
                id="ippPastServiceYears"
                value={formData.ippPastServiceYears || ''}
                onChange={v => handleNumberChange('ippPastServiceYears', v)}
                tooltip={INPUT_TOOLTIPS.ippPastServiceYears}
                hint="Years credited at IPP setup"
              />
              <InputField
                label="Current Fund Balance (FMV)"
                id="ippExistingFundBalance"
                value={formData.ippExistingFundBalance || ''}
                onChange={v => handleNumberChange('ippExistingFundBalance', v)}
                tooltip={INPUT_TOOLTIPS.ippExistingFundBalance}
                prefix="$"
              />
              <InputField
                label="Last Valuation Year"
                id="ippLastValuationYear"
                value={formData.ippLastValuationYear || ''}
                onChange={v => handleNumberChange('ippLastValuationYear', v)}
                tooltip={INPUT_TOOLTIPS.ippLastValuationYear}
                placeholder="2023"
              />
              <InputField
                label="Actuarial Liability (from report)"
                id="ippLastValuationLiability"
                value={formData.ippLastValuationLiability || ''}
                onChange={v => handleNumberChange('ippLastValuationLiability', v)}
                tooltip={INPUT_TOOLTIPS.ippLastValuationLiability}
                prefix="$"
              />
              <InputField
                label="Annual Contribution (from report)"
                id="ippLastValuationAnnualContribution"
                value={formData.ippLastValuationAnnualContribution || ''}
                onChange={v => handleNumberChange('ippLastValuationAnnualContribution', v)}
                tooltip={INPUT_TOOLTIPS.ippLastValuationAnnualContribution}
                prefix="$"
              />
            </div>

            {/* Funding status display — computed inline from ipp.ts */}
            {formData.ippExistingFundBalance &&
              formData.ippLastValuationYear &&
              formData.ippLastValuationLiability &&
              formData.ippLastValuationAnnualContribution && (() => {
                const currentYear = formData.startingYear;
                const targetLiability = estimateCurrentTargetLiability(
                  formData.ippLastValuationLiability,
                  formData.ippLastValuationYear,
                  formData.ippLastValuationAnnualContribution,
                  currentYear,
                );
                const status = calculateFundingStatus(formData.ippExistingFundBalance, targetLiability);
                const totalServiceYears = (formData.ippYearsOfService || 0) + (formData.ippPastServiceYears || 0);
                const best3Salary = formData.ippBest3AvgSalary || formData.requiredIncome;
                const retirementYear = currentYear + (formData.retirementAge - formData.currentAge);
                const projectedPension = calculateProjectedPension(totalServiceYears, best3Salary, retirementYear);
                const projectedFundAtRetirement = formData.ippExistingFundBalance *
                  Math.pow(1 + formData.investmentReturnRate, formData.retirementAge - formData.currentAge) +
                  (formData.ippLastValuationAnnualContribution || 0) *
                    ((Math.pow(1 + formData.investmentReturnRate, formData.retirementAge - formData.currentAge) - 1) /
                      formData.investmentReturnRate);
                const terminalFunding = estimateTerminalFunding(projectedFundAtRetirement, projectedPension);
                return (
                  <div className="p-4 rounded-lg space-y-2" style={{ background: 'var(--bg-base)', border: '1px solid var(--border-subtle)' }}>
                    <p className="text-xs font-semibold uppercase tracking-wide mb-3" style={{ color: 'var(--text-dim)' }}>Funding Estimate (between valuations)</p>
                    <div className="grid grid-cols-2 gap-3 text-sm">
                      <div>
                        <p style={{ color: 'var(--text-dim)' }}>Est. target liability</p>
                        <p className="font-medium" style={{ color: 'var(--text-primary)' }}>${Math.round(targetLiability).toLocaleString()}</p>
                      </div>
                      <div>
                        <p style={{ color: 'var(--text-dim)' }}>Current fund (FMV)</p>
                        <p className="font-medium" style={{ color: 'var(--text-primary)' }}>${Math.round(formData.ippExistingFundBalance).toLocaleString()}</p>
                      </div>
                      <div>
                        <p style={{ color: 'var(--text-dim)' }}>{status.deficiencyLikely ? 'Funding gap ⚠' : 'Surplus'}</p>
                        <p className="font-medium" style={{ color: status.deficiencyLikely ? 'var(--color-warning, #f59e0b)' : 'var(--color-success, #10b981)' }}>
                          ${Math.round(status.deficiencyLikely ? status.gap : status.surplus).toLocaleString()}
                        </p>
                      </div>
                      <div>
                        <p style={{ color: 'var(--text-dim)' }}>Projected pension/yr</p>
                        <p className="font-medium" style={{ color: 'var(--text-primary)' }}>${Math.round(projectedPension).toLocaleString()}</p>
                      </div>
                      {terminalFunding > 0 && (
                        <div className="col-span-2">
                          <p style={{ color: 'var(--text-dim)' }}>Est. terminal funding room at retirement</p>
                          <p className="font-medium" style={{ color: 'var(--text-primary)' }}>~${Math.round(terminalFunding).toLocaleString()} additional deductible</p>
                        </div>
                      )}
                      {status.contributionHolidayTriggered && (
                        <div className="col-span-2 p-2 rounded" style={{ background: 'var(--accent-primary-glow)' }}>
                          <p className="text-xs" style={{ color: 'var(--accent-primary)' }}>⚠ Fund may exceed the 25% surplus limit — contribution holiday may apply at next valuation.</p>
                        </div>
                      )}
                    </div>
                    <p className="text-xs mt-3" style={{ color: 'var(--text-dim)' }}>Planning estimates only. Formal funding status determined at next actuarial valuation.</p>
                  </div>
                );
              })()}
          </div>
        )}

        {/* Admin costs info box */}
        <div className="p-3 rounded-lg text-xs" style={{ background: 'var(--bg-base)', color: 'var(--text-muted)' }}>
          IPP setup cost: ~$3,000–$5,000 one-time. Annual actuarial + admin: ~$2,500–$4,000/yr. Triennial valuation: ~$3,000–$5,000.
        </div>
      </div>
    )}
  </div>
)}
```

**Step 3: Add imports for IPP functions at top of InputFormClean.tsx**

```typescript
import {
  estimateCurrentTargetLiability,
  calculateFundingStatus,
  calculateProjectedPension,
  estimateTerminalFunding,
} from '../lib/tax/ipp';
```

**Step 4: Manually test the IPP section**

```bash
npm run dev
```

- Expand the IPP section
- Check "Include IPP Analysis"
- Try "Considering" mode — verify basic fields appear
- Switch to "Already have one" — verify additional fields appear
- Fill in all fields — verify funding status panel appears with correct numbers
- Verify the disclaimer text appears at bottom

**Step 5: Run full test suite**

```bash
npx vitest run
```
Expected: all tests pass.

**Step 6: Commit**

```bash
git add src/components/InputFormClean.tsx src/components/Tooltip.tsx
git commit -m "feat: IPP section expanded — considering/existing modes, funding status display panel"
```

---

## TASK 7: Restructure full form sections

**Files:**
- Modify: `src/components/InputFormClean.tsx`

**Context:** This is the largest single-file change. We're:
1. Deleting the "Inflation & Indexing" ghost section
2. Adding new "Retirement & Government Benefits" section (pulling CPP/OAS/retirement spending out of Basic Advanced)
3. Adding new "RRSP & TFSA" section (pulling those fields out of Basic Advanced and Strategy Advanced)
4. Updating `expandedSections` state to match new section list
5. Making the advanced toggle button more visible

Work through these one by one. Read the current file carefully before editing.

**Step 1: Update expandedSections state**

Change the `expandedSections` useState from:
```typescript
{
  basic: true,
  portfolio: true,
  balances: true,
  inflation: false,
  strategy: false,
  debt: false,
  ipp: false,
  spouse: false,
}
```

To:
```typescript
{
  basic: true,
  retirement: true,    // new — Retirement & Government Benefits
  portfolio: true,
  rrspTfsa: false,    // new — RRSP & TFSA
  strategy: false,
  balances: false,
  debt: false,
  ipp: false,
  spouse: false,
  // 'inflation' removed — ghost section deleted
}
```

**Step 2: Update advancedOpen state**

Change from:
```typescript
{ basic: false, accounts: false, portfolio: false, strategy: false }
```
To:
```typescript
{ basic: false, accounts: false, portfolio: false }
// 'strategy' removed — strategy section no longer has an advanced toggle
// salary strategy select is always visible in the strategy section
```

**Step 3: Remove fields from Basic Advanced**

From the `advancedOpen.basic` block, remove:
- Planning End Age (stays in basic advanced — OK to keep)
- Starting Year (stays in basic advanced — OK)
- Expected Inflation Rate (stays — add tooltip about indexation here instead of ghost section)
- Inflate Spending Needs (stays)
- **REMOVE: Retirement Spending** → moves to new Retirement section
- **REMOVE: Lifetime Objective** → moves to new Retirement section
- **REMOVE: CPP Start Age** → moves to new Retirement section
- **REMOVE: Age Started Earning** → moves to new Retirement section
- **REMOVE: Avg Historical Salary** → moves to new Retirement section
- **REMOVE: OAS Eligible** → moves to new Retirement section
- **REMOVE: OAS Start Age** → moves to new Retirement section
- **REMOVE: Available RRSP Room** → moves to RRSP & TFSA section
- **REMOVE: Actual RRSP Balance** → moves to RRSP & TFSA section
- **REMOVE: Available TFSA Room** → moves to RRSP & TFSA section
- **REMOVE: Actual TFSA Balance** → moves to RRSP & TFSA section

**Step 4: Add new "Retirement & Government Benefits" section**

After the Basic Information section's closing `</div>`, add a new section:

```tsx
{/* Retirement & Government Benefits */}
<div className="p-4 rounded-xl" style={{ background: 'var(--bg-elevated)', border: '1px solid var(--border-subtle)' }}>
  <SectionHeader
    title="Retirement & Government Benefits"
    section="retirement"
    description="Retirement spending target, CPP, OAS"
  />
  {expandedSections.retirement && (
    <div className="pt-4 mt-2 animate-fade-in space-y-4" style={{ borderTop: '1px solid var(--border-subtle)' }}>
      <div className="grid grid-cols-1 md:grid-cols-2 gap-5">
        <InputField
          label="Retirement Spending Target"
          id="retirementSpending"
          value={formData.retirementSpending}
          onChange={v => handleNumberChange('retirementSpending', v)}
          prefix="$"
          tooltip={INPUT_TOOLTIPS.retirementSpending}
          hint="Annual spending in today's dollars"
        />
        <div>
          <InfoLabel label="Lifetime Objective" tooltip={INPUT_TOOLTIPS.lifetimeObjective} htmlFor="lifetimeObjective" />
          <select
            id="lifetimeObjective"
            value={formData.lifetimeObjective}
            onChange={e => setFormData({ ...formData, lifetimeObjective: e.target.value as UserInputs['lifetimeObjective'] })}
            className="mt-1 w-full px-3 py-2 rounded-lg text-sm"
            style={{ background: 'var(--bg-input)', border: '1px solid var(--border-default)', color: 'var(--text-primary)' }}
          >
            <option value="balanced">Balanced</option>
            <option value="maximize-spending">Maximize Retirement Spending</option>
            <option value="maximize-estate">Maximize Estate</option>
          </select>
        </div>
      </div>
      <div className="grid grid-cols-1 md:grid-cols-3 gap-5">
        <InputField
          label="CPP Start Age"
          id="cppStartAge"
          value={formData.cppStartAge}
          onChange={v => handleNumberChange('cppStartAge', v)}
          tooltip={INPUT_TOOLTIPS.cppStartAge}
        />
        <InputField
          label="Age Started Earning"
          id="salaryStartAge"
          value={formData.salaryStartAge}
          onChange={v => handleNumberChange('salaryStartAge', v)}
          tooltip={INPUT_TOOLTIPS.salaryStartAge}
          hint="For CPP calculation"
        />
        <InputField
          label="Avg. Historical Salary"
          id="averageHistoricalSalary"
          value={formData.averageHistoricalSalary}
          onChange={v => handleNumberChange('averageHistoricalSalary', v)}
          prefix="$"
          tooltip={INPUT_TOOLTIPS.averageHistoricalSalary}
          hint="For CPP calculation"
        />
      </div>
      <div className="grid grid-cols-1 md:grid-cols-3 gap-5">
        <div>
          <label className="flex items-center gap-2 cursor-pointer text-sm font-medium" style={{ color: 'var(--text-secondary)' }}>
            <input
              type="checkbox"
              checked={formData.oasEligible ?? true}
              onChange={e => setFormData({ ...formData, oasEligible: e.target.checked })}
              className="w-4 h-4 rounded"
            />
            <span>
              OAS Eligible
              <Tooltip content={INPUT_TOOLTIPS.oasEligible} />
            </span>
          </label>
          <p className="text-xs mt-1.5" style={{ color: 'var(--text-dim)' }}>10+ years Canadian residency</p>
        </div>
        {formData.oasEligible !== false && (
          <InputField
            label="OAS Start Age"
            id="oasStartAge"
            value={formData.oasStartAge}
            onChange={v => handleNumberChange('oasStartAge', v)}
            tooltip={INPUT_TOOLTIPS.oasStartAge}
          />
        )}
      </div>
    </div>
  )}
</div>
```

**Step 5: Add new "RRSP & TFSA" section**

After the Portfolio Composition section, add:

```tsx
{/* RRSP & TFSA */}
<div className="p-4 rounded-xl" style={{ background: 'var(--bg-elevated)', border: '1px solid var(--border-subtle)' }}>
  <SectionHeader
    title="RRSP & TFSA"
    section="rrspTfsa"
    description="Contribution room, balances, and contribution preferences"
  />
  {expandedSections.rrspTfsa && (
    <div className="pt-4 mt-2 animate-fade-in space-y-4" style={{ borderTop: '1px solid var(--border-subtle)' }}>
      <div className="grid grid-cols-1 md:grid-cols-2 gap-5">
        <InputField
          label="Available RRSP Room"
          id="rrspBalance"
          value={formData.rrspBalance}
          onChange={v => handleNumberChange('rrspBalance', v)}
          prefix="$"
          tooltip={INPUT_TOOLTIPS.rrspRoom}
          hint="From your CRA My Account"
        />
        <InputField
          label="Actual RRSP Balance"
          id="actualRRSPBalance"
          value={formData.actualRRSPBalance}
          onChange={v => handleNumberChange('actualRRSPBalance', v)}
          prefix="$"
          tooltip={INPUT_TOOLTIPS.actualRRSPBalance}
        />
        <InputField
          label="Available TFSA Room"
          id="tfsaBalance"
          value={formData.tfsaBalance}
          onChange={v => handleNumberChange('tfsaBalance', v)}
          prefix="$"
          tooltip={INPUT_TOOLTIPS.tfsaRoom}
          hint="From your CRA My Account"
        />
        <InputField
          label="Actual TFSA Balance"
          id="actualTFSABalance"
          value={formData.actualTFSABalance}
          onChange={v => handleNumberChange('actualTFSABalance', v)}
          prefix="$"
          tooltip={INPUT_TOOLTIPS.actualTFSABalance}
        />
      </div>
      <div className="grid grid-cols-1 md:grid-cols-2 gap-5">
        <label className="flex items-center gap-2 cursor-pointer text-sm font-medium" style={{ color: 'var(--text-secondary)' }}>
          <input
            type="checkbox"
            checked={formData.contributeToRRSP}
            onChange={e => setFormData({ ...formData, contributeToRRSP: e.target.checked })}
            className="w-4 h-4 rounded"
          />
          <span>
            Contribute to RRSP
            <Tooltip content={INPUT_TOOLTIPS.contributeToRRSP} />
          </span>
        </label>
        <label className="flex items-center gap-2 cursor-pointer text-sm font-medium" style={{ color: 'var(--text-secondary)' }}>
          <input
            type="checkbox"
            checked={formData.maximizeTFSA}
            onChange={e => setFormData({ ...formData, maximizeTFSA: e.target.checked })}
            className="w-4 h-4 rounded"
          />
          <span>
            Maximize TFSA
            <Tooltip content={INPUT_TOOLTIPS.maximizeTFSA} />
          </span>
        </label>
      </div>
    </div>
  )}
</div>
```

**Step 6: Delete the "Inflation & Indexing" ghost section**

Find and delete the entire block:
```tsx
{/* Inflation & Indexing — collapsed by default, fields kept for completeness */}
<div className="p-4 rounded-xl" ...>
  <SectionHeader title="Inflation & Indexing" section="inflation" ... />
  ...
</div>
```

**Step 7: Update Strategy section**

Remove the `advancedOpen.strategy` toggle from the Strategy section. Make the salary strategy select always visible (not behind an advanced toggle). Remove "Maximize TFSA" and "Contribute to RRSP" from this section (they moved to RRSP & TFSA). The strategy section now just shows:
- Strategy description text
- Salary Strategy select (always visible)
- Fixed Salary Amount (conditional on fixed)

**Step 8: Update the AdvancedToggle button styling**

Find the `AdvancedToggle` component (or wherever the advanced button is rendered). Make it visually prominent:

```tsx
function AdvancedToggle({ section, open, onToggle }: { section: string; open: boolean; onToggle: () => void }) {
  return (
    <button
      type="button"
      onClick={onToggle}
      className="flex items-center gap-1.5 px-3 py-1.5 rounded-full text-xs font-medium transition-colors"
      style={{
        border: '1px solid var(--border-default)',
        color: open ? 'var(--accent-primary)' : 'var(--text-secondary)',
        background: open ? 'var(--accent-primary-glow)' : 'var(--bg-elevated)',
      }}
    >
      <svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
        <circle cx="12" cy="12" r="3" />
        <path d="M19.07 4.93a10 10 0 0 1 0 14.14M4.93 4.93a10 10 0 0 0 0 14.14" />
      </svg>
      {open ? 'Hide advanced' : 'Advanced settings'}
    </button>
  );
}
```

**Step 9: Manually test all sections**

```bash
npm run dev
```

Verify:
- Basic Information: 6 fields visible, Advanced toggle shows 4 fields (planning end age, starting year, inflation rate, inflate spending)
- Retirement & Government Benefits: expanded by default, all CPP/OAS/spending fields visible
- Portfolio Composition: unchanged
- RRSP & TFSA: collapsed by default, shows room + balance + checkboxes
- Compensation Strategy: shows salary strategy without an advanced toggle
- Notional Account Balances: unchanged
- Debt Management: multi-debt (from Task 5)
- IPP Analysis: expanded (from Task 6)
- Spouse: unchanged
- No "Inflation & Indexing" ghost section

**Step 10: Run full test suite**

```bash
npx vitest run
```
Expected: all tests pass.

**Step 11: Commit**

```bash
git add src/components/InputFormClean.tsx
git commit -m "feat: restructure form — Retirement & Govt Benefits section, RRSP & TFSA section, delete ghost Inflation section, improve advanced toggle styling"
```

---

## TASK 8: Setup Wizard — step components

**Files:**
- Create: `src/components/wizard/SetupWizard.tsx`
- Create: `src/components/wizard/steps/Step1AboutYou.tsx`
- Create: `src/components/wizard/steps/Step2YourPractice.tsx`
- Create: `src/components/wizard/steps/Step3Retirement.tsx`
- Create: `src/components/wizard/steps/Step4Investments.tsx`
- Create: `src/components/wizard/steps/Step5Debts.tsx`
- Create: `src/components/wizard/steps/Step6IPP.tsx`
- Create: `src/components/wizard/steps/Step7Spouse.tsx`

**Context:** The wizard is a new component that overlays/replaces the form on first visit. It passes partial `UserInputs` between steps and on completion calls `onComplete(inputs)` which App.tsx uses to trigger calculation.

**Step 1: Create SetupWizard.tsx orchestrator**

```tsx
// src/components/wizard/SetupWizard.tsx
import { useState } from 'react';
import type { UserInputs } from '../../lib/types';
import { getDefaultInputs } from '../../lib/localStorage';
import { Step1AboutYou } from './steps/Step1AboutYou';
import { Step2YourPractice } from './steps/Step2YourPractice';
import { Step3Retirement } from './steps/Step3Retirement';
import { Step4Investments } from './steps/Step4Investments';
import { Step5Debts } from './steps/Step5Debts';
import { Step6IPP } from './steps/Step6IPP';
import { Step7Spouse } from './steps/Step7Spouse';

interface SetupWizardProps {
  onComplete: (inputs: UserInputs) => void;
}

const STEP_LABELS = [
  'About You',
  'Your Practice',
  'Retirement',
  'Investments',
  'Debts',
  'IPP',
  'Spouse',
];

export function SetupWizard({ onComplete }: SetupWizardProps) {
  const [step, setStep] = useState(1);
  const [inputs, setInputs] = useState<UserInputs>(getDefaultInputs());

  const update = (partial: Partial<UserInputs>) =>
    setInputs(prev => ({ ...prev, ...partial }));

  const next = () => setStep(s => Math.min(s + 1, 7));
  const back = () => setStep(s => Math.max(s - 1, 1));
  const skip = () => next();
  const finish = () => onComplete(inputs);

  const stepProps = { inputs, update, onNext: next, onBack: back, onSkip: skip, onFinish: finish };

  return (
    <div className="max-w-2xl mx-auto space-y-6">
      {/* Progress bar */}
      <div className="space-y-2">
        <div className="flex justify-between text-xs" style={{ color: 'var(--text-dim)' }}>
          <span>Step {step} of 7</span>
          <span>{STEP_LABELS[step - 1]}</span>
        </div>
        <div className="h-1.5 rounded-full" style={{ background: 'var(--border-subtle)' }}>
          <div
            className="h-1.5 rounded-full transition-all duration-300"
            style={{ width: `${(step / 7) * 100}%`, background: 'var(--accent-primary)' }}
          />
        </div>
        <div className="flex gap-1 justify-center mt-2">
          {STEP_LABELS.map((_, i) => (
            <div
              key={i}
              className="w-2 h-2 rounded-full transition-colors"
              style={{ background: i + 1 <= step ? 'var(--accent-primary)' : 'var(--border-subtle)' }}
            />
          ))}
        </div>
      </div>

      {/* Step content */}
      <div className="glass-card p-6">
        {step === 1 && <Step1AboutYou {...stepProps} />}
        {step === 2 && <Step2YourPractice {...stepProps} />}
        {step === 3 && <Step3Retirement {...stepProps} />}
        {step === 4 && <Step4Investments {...stepProps} />}
        {step === 5 && <Step5Debts {...stepProps} />}
        {step === 6 && <Step6IPP {...stepProps} />}
        {step === 7 && <Step7Spouse {...stepProps} />}
      </div>
    </div>
  );
}
```

**Step 2: Create shared WizardStepProps type and nav buttons**

At the top of `SetupWizard.tsx` (or a separate `wizard/types.ts`), add:

```typescript
export interface WizardStepProps {
  inputs: UserInputs;
  update: (partial: Partial<UserInputs>) => void;
  onNext: () => void;
  onBack: () => void;
  onSkip: () => void;
  onFinish: () => void;
}

export function WizardNav({
  onBack, onNext, onSkip, onFinish,
  isFirst, isLast, skippable, nextLabel,
}: {
  onBack: () => void; onNext: () => void; onSkip?: () => void; onFinish?: () => void;
  isFirst?: boolean; isLast?: boolean; skippable?: boolean; nextLabel?: string;
}) {
  return (
    <div className="flex items-center justify-between pt-4 mt-4" style={{ borderTop: '1px solid var(--border-subtle)' }}>
      <div>
        {!isFirst && (
          <button type="button" onClick={onBack}
            className="px-4 py-2 rounded-lg text-sm" style={{ color: 'var(--text-secondary)' }}>
            ← Back
          </button>
        )}
      </div>
      <div className="flex gap-2">
        {skippable && onSkip && (
          <button type="button" onClick={onSkip}
            className="px-4 py-2 rounded-lg text-sm" style={{ color: 'var(--text-dim)' }}>
            Skip
          </button>
        )}
        <button type="button" onClick={isLast ? onFinish : onNext}
          className="px-6 py-2 rounded-lg text-sm font-medium"
          style={{ background: 'var(--accent-primary)', color: 'white' }}>
          {isLast ? 'See my results →' : (nextLabel ?? 'Next →')}
        </button>
      </div>
    </div>
  );
}
```

**Step 3: Create Step1AboutYou.tsx**

```tsx
// src/components/wizard/steps/Step1AboutYou.tsx
import type { WizardStepProps } from '../SetupWizard';
import { WizardNav } from '../SetupWizard';
import { PROVINCES } from '../../../lib/tax/provinces';

export function Step1AboutYou({ inputs, update, onNext }: WizardStepProps) {
  return (
    <div className="space-y-5">
      <div>
        <h2 className="text-lg font-semibold" style={{ color: 'var(--text-primary)' }}>About You</h2>
        <p className="text-sm mt-1" style={{ color: 'var(--text-secondary)' }}>
          Where you practice and your timeline determine the tax rates and CPP projections.
        </p>
      </div>

      <div className="space-y-4">
        <div>
          <label className="block text-sm font-medium mb-1" style={{ color: 'var(--text-secondary)' }}>Province</label>
          <select
            value={inputs.province}
            onChange={e => update({ province: e.target.value as typeof inputs.province })}
            className="w-full px-3 py-2 rounded-lg"
            style={{ background: 'var(--bg-input)', border: '1px solid var(--border-default)', color: 'var(--text-primary)' }}
          >
            {PROVINCES.map(p => <option key={p.code} value={p.code}>{p.name}</option>)}
          </select>
        </div>

        <div className="grid grid-cols-2 gap-4">
          <div>
            <label className="block text-sm font-medium mb-1" style={{ color: 'var(--text-secondary)' }}>Current Age</label>
            <input type="text" inputMode="decimal"
              value={inputs.currentAge || ''}
              onChange={e => { const v = parseInt(e.target.value); if (!isNaN(v)) update({ currentAge: v }); }}
              placeholder="45"
              className="w-full px-3 py-2 rounded-lg"
              style={{ background: 'var(--bg-input)', border: '1px solid var(--border-default)', color: 'var(--text-primary)' }}
            />
          </div>
          <div>
            <label className="block text-sm font-medium mb-1" style={{ color: 'var(--text-secondary)' }}>Planned Retirement Age</label>
            <input type="text" inputMode="decimal"
              value={inputs.retirementAge || ''}
              onChange={e => { const v = parseInt(e.target.value); if (!isNaN(v)) update({ retirementAge: v }); }}
              placeholder="65"
              className="w-full px-3 py-2 rounded-lg"
              style={{ background: 'var(--bg-input)', border: '1px solid var(--border-default)', color: 'var(--text-primary)' }}
            />
          </div>
        </div>
      </div>

      <WizardNav onBack={() => {}} onNext={onNext} onSkip={() => {}} onFinish={() => {}} isFirst />
    </div>
  );
}
```

**Step 4: Create remaining step components** (Steps 2-7)

Each follows the same pattern. Create them with the fields from the design doc. Here are the key fields per step — implement each analogously to Step 1:

**Step2YourPractice.tsx:** `requiredIncome` ($), `corporateInvestmentBalance` ($), `annualCorporateRetainedEarnings` ($)

**Step3Retirement.tsx:** `retirementSpending` ($), `lifetimeObjective` (select), `cppStartAge`, `oasEligible` (checkbox), `oasStartAge` (conditional)

**Step4Investments.tsx:** 4 allocation inputs (canadianEquityPercent, usEquityPercent, internationalEquityPercent, fixedIncomePercent) that must sum to 100 — show live validation message if not. Show blended return read-only (import `computeBlendedReturnRate`).

**Step5Debts.tsx:** "Do you have any debts?" toggle. If yes, show DebtRow components (reuse the debt row logic from Task 5 — extract a `DebtRow` component from InputFormClean). Skippable.

**Step6IPP.tsx:** "Are you considering or do you have an IPP?" toggle. If yes, show Age + Years of Service + Mode toggle. Just the basics — the full funding analysis is in the form. Skippable.

**Step7Spouse.tsx:** "Include a spouse?" toggle. If yes: `spouseRequiredIncome` ($), `spouseCurrentAge`, `spouseRetirementAge`, `spouseRRSPRoom` ($), `spouseTFSARoom` ($). Last step — onNext calls `onFinish`. Skippable.

**Step 5: Run full test suite**

```bash
npx vitest run
```
Expected: all tests pass (wizard components have no logic to test, all logic is in the engine).

**Step 6: Commit**

```bash
git add src/components/wizard/
git commit -m "feat: setup wizard — 7-step guided onboarding with progress bar and skip navigation"
```

---

## TASK 9: Wire wizard into App.tsx

**Files:**
- Modify: `src/App.tsx`
- Modify: `src/lib/localStorage.ts` (add `markWizardComplete()` and `hasCompletedWizard()`)

**Context:** The wizard shows on first visit (no localStorage). On completion it saves inputs and triggers calculation. After that, returning visits go straight to the full form.

**Step 1: Add wizard state helpers to localStorage.ts**

```typescript
const WIZARD_COMPLETE_KEY = 'ccpc-wizard-complete';

export function hasCompletedWizard(): boolean {
  try {
    return localStorage.getItem(WIZARD_COMPLETE_KEY) === 'true';
  } catch {
    return false;
  }
}

export function markWizardComplete(): void {
  try {
    localStorage.setItem(WIZARD_COMPLETE_KEY, 'true');
  } catch {
    // ignore
  }
}
```

**Step 2: Wire wizard into App.tsx**

In `App.tsx`, add:

```typescript
import { SetupWizard } from './components/wizard/SetupWizard';
import { hasCompletedWizard, markWizardComplete, saveInputsToStorage } from './lib/localStorage';
```

Add state:
```typescript
const [showWizard, setShowWizard] = useState(
  !hasCompletedWizard() && !getInputsFromUrl() // skip wizard if loading share link
);
```

Add a "Start over" button near the top of the form view (next to existing controls):
```tsx
<button
  onClick={() => {
    clearStoredInputs();
    localStorage.removeItem('ccpc-wizard-complete');
    setShowWizard(true);
    setResults(null);
  }}
  className="text-xs px-2 py-1 rounded"
  style={{ color: 'var(--text-dim)' }}
>
  Start over
</button>
```

Replace the `<InputFormClean>` section in the calculator view with:

```tsx
{showWizard ? (
  <SetupWizard
    onComplete={(inputs) => {
      saveInputsToStorage(inputs);
      markWizardComplete();
      setShowWizard(false);
      setInitialInputs(inputs);
      handleCalculate(inputs); // trigger calculation immediately
    }}
  />
) : (
  <section className="glass-card p-6">
    <InputFormClean onCalculate={handleCalculate} initialInputs={initialInputs} />
  </section>
)}
```

**Step 3: Manually test the full flow**

```bash
npm run dev
```

Test the following:
1. Clear localStorage, open app → wizard appears
2. Complete wizard → results appear immediately
3. Reload app → wizard does NOT appear, full form shows with saved inputs
4. Click "Start over" → wizard appears again
5. Open a share link URL → wizard is skipped, form loads with shared inputs

**Step 4: Run full test suite**

```bash
npx vitest run
```
Expected: all tests pass.

**Step 5: Commit**

```bash
git add src/App.tsx src/lib/localStorage.ts
git commit -m "feat: wizard wired into App — shows on first visit, skipped on return, Start Over resets"
```

---

## TASK 10: Final verification + push

**Step 1: Run full test suite**

```bash
cd "/Users/home/Documents/Vibe Coding/Project Ideas/Optimal Compensation Calculator/optimal-compensation-calculator" && npx vitest run
```
Expected: all tests pass.

**Step 2: TypeScript check**

```bash
npx tsc -p tsconfig.app.json --noEmit 2>&1 | grep -v "ScenarioBuilder\|MonteCarloResults\|boundaryStress\|WinnerStrategyCard\|calculator.test\|craPersonalTax\|dollarTrace"
```
Expected: no new errors from v3.4 changes.

**Step 3: Manual smoke test checklist**

- [ ] Wizard appears on first visit (clear localStorage first)
- [ ] All 7 wizard steps work, Back/Next/Skip navigate correctly
- [ ] Wizard completion triggers calculation and shows results
- [ ] Returning visit skips wizard, shows full form
- [ ] Full form has 9 sections in correct order
- [ ] Retirement & Government Benefits shows CPP/OAS fields
- [ ] RRSP & TFSA section exists and works
- [ ] No "Inflation & Indexing" section
- [ ] Advanced toggle buttons are visually prominent
- [ ] Debt section: add/remove rows, frequency dropdown
- [ ] IPP section: considering mode shows break-even analysis
- [ ] IPP section: existing mode shows funding status panel
- [ ] Share links still work (encode/decode correctly)
- [ ] localStorage auto-saves and loads correctly

**Step 4: Push**

```bash
git push origin main
```

---

## Implementation Order

Tasks must be done in order — each depends on the previous:

1. Task 1: Types + DebtEntry (data model foundation)
2. Task 2: Calculator wiring (engine)
3. Task 3: IPP engine expansion (engine)
4. Task 4: Share link (serialization)
5. Task 5: Multi-debt UI (form)
6. Task 6: IPP UI expansion (form)
7. Task 7: Form restructure (form)
8. Task 8: Wizard step components (wizard)
9. Task 9: Wire wizard into App (app integration)
10. Task 10: Final verification

---

## What NOT to change

- `src/lib/calculator.ts` internals (beyond the debt aggregation adapter in Task 2)
- `src/lib/strategyComparison.ts`
- `src/lib/monteCarlo.ts` / `src/workers/monteCarlo.worker.ts`
- Results tabs (Summary, RecommendedTab, CompareAllTab, DetailsTab, DashboardTab, ExportTab)
- PDF export / ReportTemplate
- Share link URL format (we add to it, don't break it)
