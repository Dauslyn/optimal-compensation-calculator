# v2.3.0 Custom Dashboard â€” Implementation Plan

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.

**Goal:** Add a 5th "Dashboard" tab where users drag widget thumbnails from a shelf onto a 2-column grid, each with a per-widget strategy selector, enabling focused side-by-side comparison of any charts/tables across strategies.

**Architecture:** New `DashboardTab` component renders a `WidgetShelf` (horizontal draggable thumbnails) and a sortable 2-column grid of `WidgetCard` wrappers. A `widgetRegistry` maps widget IDs to existing chart/table components. `@dnd-kit` handles all drag-and-drop. Layout persists to `localStorage`. No new chart/table components â€” all reuse existing ones.

**Tech Stack:** React 19, TypeScript 5.9, @dnd-kit/core + @dnd-kit/sortable + @dnd-kit/utilities, Tailwind CSS v4, Recharts 3, Vitest 4, localStorage

---

## Task 1: Install @dnd-kit Dependencies

**Files:**
- Modify: `package.json`

**Step 1: Install packages**

Run:
```bash
cd "/Users/home/Documents/Vibe Coding/Project Ideas/Optimal Compensation Calculator/optimal-compensation-calculator"
npm install @dnd-kit/core @dnd-kit/sortable @dnd-kit/utilities
```

**Step 2: Verify installation**

Run:
```bash
cd "/Users/home/Documents/Vibe Coding/Project Ideas/Optimal Compensation Calculator/optimal-compensation-calculator"
npm ls @dnd-kit/core @dnd-kit/sortable @dnd-kit/utilities
```
Expected: All three packages listed without errors.

**Step 3: Verify existing tests still pass**

Run:
```bash
cd "/Users/home/Documents/Vibe Coding/Project Ideas/Optimal Compensation Calculator/optimal-compensation-calculator"
npx vitest run
```
Expected: All 1,449 tests pass.

**Step 4: Commit**

```bash
git add package.json package-lock.json
git commit -m "chore: install @dnd-kit/core, @dnd-kit/sortable, @dnd-kit/utilities for dashboard drag-and-drop"
```

---

## Task 2: Create Dashboard Types and Widget Registry

**Files:**
- Create: `src/components/dashboard/types.ts`
- Create: `src/components/dashboard/widgetRegistry.ts`

**Step 1: Write the failing test**

Create `src/lib/__tests__/dashboard.test.ts`:

```typescript
/**
 * Tests for v2.3.0 "Custom Dashboard":
 * - Widget registry has all expected widgets
 * - Each widget has required fields (id, label, icon, category)
 * - Dashboard layout persistence to/from localStorage
 * - Widget instance creation and removal
 * - Strategy ID validation
 */

import { describe, it, expect, beforeEach } from 'vitest';
import {
  WIDGET_REGISTRY,
  type WidgetDefinition,
  type DashboardWidget,
} from '../../components/dashboard/widgetRegistry';

describe('Widget Registry', () => {
  it('contains at least 12 widget definitions', () => {
    expect(Object.keys(WIDGET_REGISTRY).length).toBeGreaterThanOrEqual(12);
  });

  it('every widget has required fields', () => {
    for (const [id, widget] of Object.entries(WIDGET_REGISTRY)) {
      expect(widget.id).toBe(id);
      expect(widget.label).toBeTruthy();
      expect(widget.icon).toBeTruthy();
      expect(['chart', 'table', 'stat']).toContain(widget.category);
    }
  });

  it('contains all expected chart widgets', () => {
    const expectedCharts = [
      'total-tax-comparison',
      'corporate-balance-over-time',
      'cumulative-tax-paid',
      'tax-breakdown',
      'compensation-mix',
      'rrsp-room',
      'effective-tax-rate',
      'compensation-by-year',
    ];
    for (const chartId of expectedCharts) {
      expect(WIDGET_REGISTRY[chartId]).toBeDefined();
      expect(WIDGET_REGISTRY[chartId].category).toBe('chart');
    }
  });

  it('contains all expected table widgets', () => {
    const expectedTables = [
      'after-tax-wealth',
      'action-plan',
      'yearly-projection',
    ];
    for (const tableId of expectedTables) {
      expect(WIDGET_REGISTRY[tableId]).toBeDefined();
      expect(WIDGET_REGISTRY[tableId].category).toBe('table');
    }
  });

  it('contains key metrics stat widget', () => {
    expect(WIDGET_REGISTRY['key-metrics']).toBeDefined();
    expect(WIDGET_REGISTRY['key-metrics'].category).toBe('stat');
  });

  it('ipp-contributions widget exists and is marked conditional', () => {
    expect(WIDGET_REGISTRY['ipp-contributions']).toBeDefined();
    expect(WIDGET_REGISTRY['ipp-contributions'].conditional).toBe(true);
  });
});
```

**Step 2: Run test to verify it fails**

Run:
```bash
cd "/Users/home/Documents/Vibe Coding/Project Ideas/Optimal Compensation Calculator/optimal-compensation-calculator"
npx vitest run src/lib/__tests__/dashboard.test.ts
```
Expected: FAIL â€” cannot resolve `../../components/dashboard/widgetRegistry`

**Step 3: Create the types file**

Create `src/components/dashboard/types.ts`:

```typescript
/**
 * Dashboard Types (v2.3.0)
 *
 * Defines the data structures for the custom dashboard feature:
 * - DashboardWidget: An instance of a widget placed on the grid
 * - WidgetDefinition: A widget template in the registry (what can be placed)
 * - DashboardLayout: The full persisted state
 */

export interface DashboardWidget {
  /** Unique instance ID (nanoid-style, e.g., "w_1", "w_2") */
  instanceId: string;
  /** Widget type from registry (e.g., "total-tax-comparison") */
  widgetType: string;
  /** Which strategy's data to show */
  strategyId: string;
}

export interface WidgetDefinition {
  /** Unique widget type ID */
  id: string;
  /** Human-readable label */
  label: string;
  /** Emoji or icon string for the shelf thumbnail */
  icon: string;
  /** Widget category */
  category: 'chart' | 'table' | 'stat';
  /** If true, widget only appears when relevant feature is enabled (e.g., IPP) */
  conditional?: boolean;
}

export interface DashboardLayout {
  widgets: DashboardWidget[];
}
```

**Step 4: Create the widget registry**

Create `src/components/dashboard/widgetRegistry.ts`:

```typescript
/**
 * Widget Registry (v2.3.0)
 *
 * Maps widget IDs to their definitions. Each widget corresponds to an
 * existing visualization component that will be rendered inside a WidgetCard.
 *
 * Re-exports types for convenience.
 */

import type { WidgetDefinition, DashboardWidget, DashboardLayout } from './types';

export type { WidgetDefinition, DashboardWidget, DashboardLayout };

export const WIDGET_REGISTRY: Record<string, WidgetDefinition> = {
  // Charts (from ComparisonCharts)
  'total-tax-comparison': {
    id: 'total-tax-comparison',
    label: 'Total Tax Comparison',
    icon: 'ðŸ“Š',
    category: 'chart',
  },
  'corporate-balance-over-time': {
    id: 'corporate-balance-over-time',
    label: 'Corporate Balance Over Time',
    icon: 'ðŸ“ˆ',
    category: 'chart',
  },
  'cumulative-tax-paid': {
    id: 'cumulative-tax-paid',
    label: 'Cumulative Tax Paid',
    icon: 'ðŸ“‰',
    category: 'chart',
  },
  // Charts (from DetailedCharts)
  'tax-breakdown': {
    id: 'tax-breakdown',
    label: 'Tax Breakdown',
    icon: 'ðŸ—ï¸',
    category: 'chart',
  },
  'compensation-mix': {
    id: 'compensation-mix',
    label: 'Compensation Mix',
    icon: 'ðŸ’°',
    category: 'chart',
  },
  'rrsp-room': {
    id: 'rrsp-room',
    label: 'RRSP Room',
    icon: 'ðŸ¦',
    category: 'chart',
  },
  'effective-tax-rate': {
    id: 'effective-tax-rate',
    label: 'Effective Tax Rate',
    icon: 'ðŸ“',
    category: 'chart',
  },
  'ipp-contributions': {
    id: 'ipp-contributions',
    label: 'IPP Contributions',
    icon: 'ðŸŽ¯',
    category: 'chart',
    conditional: true,
  },
  // Chart (from Chart component)
  'compensation-by-year': {
    id: 'compensation-by-year',
    label: 'Compensation by Year',
    icon: 'ðŸ“…',
    category: 'chart',
  },
  // Tables
  'after-tax-wealth': {
    id: 'after-tax-wealth',
    label: 'After-Tax Wealth Scenarios',
    icon: 'ðŸ’Ž',
    category: 'table',
  },
  'action-plan': {
    id: 'action-plan',
    label: 'Year-by-Year Action Plan',
    icon: 'âœ…',
    category: 'table',
  },
  'yearly-projection': {
    id: 'yearly-projection',
    label: 'Full Yearly Projection',
    icon: 'ðŸ“‹',
    category: 'table',
  },
  // Stat Cards
  'key-metrics': {
    id: 'key-metrics',
    label: 'Key Metrics Summary',
    icon: 'ðŸŽ¯',
    category: 'stat',
  },
};

/** Get all widget definitions as an array, optionally filtered by feature flags */
export function getAvailableWidgets(options?: { ippEnabled?: boolean }): WidgetDefinition[] {
  return Object.values(WIDGET_REGISTRY).filter(w => {
    if (w.conditional && w.id === 'ipp-contributions' && !options?.ippEnabled) {
      return false;
    }
    return true;
  });
}

/** Strategy IDs used across the app */
export const STRATEGY_IDS = ['salary-at-ympe', 'dividends-only', 'dynamic'] as const;
export type StrategyId = typeof STRATEGY_IDS[number];

/** Create a new dashboard widget instance */
let instanceCounter = 0;
export function createWidgetInstance(widgetType: string, strategyId: string): DashboardWidget {
  instanceCounter++;
  return {
    instanceId: `w_${Date.now()}_${instanceCounter}`,
    widgetType,
    strategyId,
  };
}
```

**Step 5: Run test to verify it passes**

Run:
```bash
cd "/Users/home/Documents/Vibe Coding/Project Ideas/Optimal Compensation Calculator/optimal-compensation-calculator"
npx vitest run src/lib/__tests__/dashboard.test.ts
```
Expected: All 6 tests PASS.

**Step 6: Run full test suite**

Run:
```bash
cd "/Users/home/Documents/Vibe Coding/Project Ideas/Optimal Compensation Calculator/optimal-compensation-calculator"
npx vitest run
```
Expected: All tests pass (1,449 existing + 6 new = 1,455).

**Step 7: Commit**

```bash
git add src/components/dashboard/types.ts src/components/dashboard/widgetRegistry.ts src/lib/__tests__/dashboard.test.ts
git commit -m "feat(dashboard): add widget registry with 13 widget definitions and types"
```

---

## Task 3: Dashboard Layout Persistence (localStorage)

**Files:**
- Create: `src/components/dashboard/dashboardStorage.ts`
- Modify: `src/lib/__tests__/dashboard.test.ts`

**Step 1: Write the failing tests**

Append to `src/lib/__tests__/dashboard.test.ts`:

```typescript
import {
  saveDashboardLayout,
  loadDashboardLayout,
  clearDashboardLayout,
  DASHBOARD_STORAGE_KEY,
} from '../../components/dashboard/dashboardStorage';
import { createWidgetInstance } from '../../components/dashboard/widgetRegistry';

describe('Dashboard Layout Persistence', () => {
  beforeEach(() => {
    localStorage.clear();
  });

  it('saves and loads a layout', () => {
    const widgets = [
      createWidgetInstance('total-tax-comparison', 'dynamic'),
      createWidgetInstance('action-plan', 'salary-at-ympe'),
    ];
    saveDashboardLayout({ widgets });

    const loaded = loadDashboardLayout();
    expect(loaded).not.toBeNull();
    expect(loaded!.widgets).toHaveLength(2);
    expect(loaded!.widgets[0].widgetType).toBe('total-tax-comparison');
    expect(loaded!.widgets[1].strategyId).toBe('salary-at-ympe');
  });

  it('returns null when no layout saved', () => {
    const loaded = loadDashboardLayout();
    expect(loaded).toBeNull();
  });

  it('clearDashboardLayout removes saved data', () => {
    saveDashboardLayout({ widgets: [createWidgetInstance('tax-breakdown', 'dynamic')] });
    expect(loadDashboardLayout()).not.toBeNull();

    clearDashboardLayout();
    expect(loadDashboardLayout()).toBeNull();
  });

  it('returns null for corrupted data', () => {
    localStorage.setItem(DASHBOARD_STORAGE_KEY, 'not-json');
    const loaded = loadDashboardLayout();
    expect(loaded).toBeNull();
  });

  it('returns null for data missing widgets array', () => {
    localStorage.setItem(DASHBOARD_STORAGE_KEY, JSON.stringify({ version: 1 }));
    const loaded = loadDashboardLayout();
    expect(loaded).toBeNull();
  });
});
```

**Step 2: Run test to verify it fails**

Run:
```bash
cd "/Users/home/Documents/Vibe Coding/Project Ideas/Optimal Compensation Calculator/optimal-compensation-calculator"
npx vitest run src/lib/__tests__/dashboard.test.ts
```
Expected: FAIL â€” cannot resolve `../../components/dashboard/dashboardStorage`

**Step 3: Implement dashboardStorage.ts**

Create `src/components/dashboard/dashboardStorage.ts`:

```typescript
/**
 * Dashboard Layout Persistence (v2.3.0)
 *
 * Saves/loads the user's custom dashboard widget layout to/from localStorage.
 * Layout includes which widgets are placed, their order, and strategy selections.
 */

import type { DashboardLayout } from './types';

export const DASHBOARD_STORAGE_KEY = 'ccpc-dashboard-v1';

const STORAGE_VERSION = 1;

interface StoredDashboard {
  version: number;
  layout: DashboardLayout;
  savedAt: string;
}

export function saveDashboardLayout(layout: DashboardLayout): void {
  try {
    const data: StoredDashboard = {
      version: STORAGE_VERSION,
      layout,
      savedAt: new Date().toISOString(),
    };
    localStorage.setItem(DASHBOARD_STORAGE_KEY, JSON.stringify(data));
  } catch (error) {
    console.error('Failed to save dashboard layout:', error);
  }
}

export function loadDashboardLayout(): DashboardLayout | null {
  try {
    const stored = localStorage.getItem(DASHBOARD_STORAGE_KEY);
    if (!stored) return null;

    const data: StoredDashboard = JSON.parse(stored);

    if (!data.layout || !Array.isArray(data.layout.widgets)) {
      console.warn('Invalid dashboard layout structure');
      return null;
    }

    return data.layout;
  } catch (error) {
    console.error('Failed to load dashboard layout:', error);
    return null;
  }
}

export function clearDashboardLayout(): void {
  try {
    localStorage.removeItem(DASHBOARD_STORAGE_KEY);
  } catch (error) {
    console.error('Failed to clear dashboard layout:', error);
  }
}
```

**Step 4: Run test to verify it passes**

Run:
```bash
cd "/Users/home/Documents/Vibe Coding/Project Ideas/Optimal Compensation Calculator/optimal-compensation-calculator"
npx vitest run src/lib/__tests__/dashboard.test.ts
```
Expected: All 11 tests PASS.

**Step 5: Commit**

```bash
git add src/components/dashboard/dashboardStorage.ts src/lib/__tests__/dashboard.test.ts
git commit -m "feat(dashboard): add layout persistence to localStorage with save/load/clear"
```

---

## Task 4: Add 'dashboard' Tab to TabNavigation

**Files:**
- Modify: `src/components/tabs/TabNavigation.tsx`
- Modify: `src/lib/__tests__/dashboard.test.ts`

**Step 1: Write the failing test**

Append to `src/lib/__tests__/dashboard.test.ts`:

```typescript
describe('TabNavigation Dashboard Tab', () => {
  it('TabId type includes dashboard', () => {
    // This is a compile-time check â€” if it compiles, the type is correct.
    // We import and assign to ensure the type exists.
    const validTabIds: Array<import('../../components/tabs/TabNavigation').TabId> = [
      'recommended', 'compare', 'details', 'dashboard', 'export',
    ];
    expect(validTabIds).toHaveLength(5);
    expect(validTabIds).toContain('dashboard');
  });
});
```

**Step 2: Run test to verify it fails**

Run:
```bash
cd "/Users/home/Documents/Vibe Coding/Project Ideas/Optimal Compensation Calculator/optimal-compensation-calculator"
npx vitest run src/lib/__tests__/dashboard.test.ts
```
Expected: FAIL â€” 'dashboard' is not assignable to type `TabId`

**Step 3: Modify TabNavigation.tsx**

In `src/components/tabs/TabNavigation.tsx`:

Change line 3:
```typescript
export type TabId = 'recommended' | 'compare' | 'details' | 'export';
```
To:
```typescript
export type TabId = 'recommended' | 'compare' | 'details' | 'dashboard' | 'export';
```

Add the dashboard tab to the TABS array (insert before 'export', after 'details'):
Change:
```typescript
const TABS: Tab[] = [
  { id: 'recommended', label: 'Recommended', icon: 'âœ“' },
  { id: 'compare', label: 'Compare All' },
  { id: 'details', label: 'Details' },
  { id: 'export', label: 'Export' },
];
```
To:
```typescript
const TABS: Tab[] = [
  { id: 'recommended', label: 'Recommended', icon: 'âœ“' },
  { id: 'compare', label: 'Compare All' },
  { id: 'details', label: 'Details' },
  { id: 'dashboard', label: 'Dashboard', icon: 'âš¡' },
  { id: 'export', label: 'Export' },
];
```

**Step 4: Run test to verify it passes**

Run:
```bash
cd "/Users/home/Documents/Vibe Coding/Project Ideas/Optimal Compensation Calculator/optimal-compensation-calculator"
npx vitest run src/lib/__tests__/dashboard.test.ts
```
Expected: All 12 tests PASS.

**Step 5: Run full test suite**

Run:
```bash
cd "/Users/home/Documents/Vibe Coding/Project Ideas/Optimal Compensation Calculator/optimal-compensation-calculator"
npx vitest run
```
Expected: All tests pass.

**Step 6: Commit**

```bash
git add src/components/tabs/TabNavigation.tsx src/lib/__tests__/dashboard.test.ts
git commit -m "feat(dashboard): add 'Dashboard' tab to TabNavigation between Details and Export"
```

---

## Task 5: Create WidgetShelf Component

**Files:**
- Create: `src/components/dashboard/WidgetShelf.tsx`

**Step 1: Create the WidgetShelf component**

This is a UI component â€” the logic it depends on (widget registry, types) is already tested. Create `src/components/dashboard/WidgetShelf.tsx`:

```typescript
/**
 * WidgetShelf (v2.3.0)
 *
 * Horizontal scrollable row of draggable widget thumbnail cards.
 * Users drag widgets from this shelf into the dashboard grid.
 * Uses @dnd-kit's useDraggable for each shelf item.
 */

import { memo } from 'react';
import { useDraggable } from '@dnd-kit/core';
import { CSS } from '@dnd-kit/utilities';
import type { WidgetDefinition } from './widgetRegistry';

interface WidgetShelfProps {
  widgets: WidgetDefinition[];
}

interface ShelfItemProps {
  widget: WidgetDefinition;
}

function ShelfItem({ widget }: ShelfItemProps) {
  const { attributes, listeners, setNodeRef, transform, isDragging } = useDraggable({
    id: `shelf-${widget.id}`,
    data: { type: 'shelf-item', widgetType: widget.id },
  });

  const style = {
    transform: CSS.Translate.toString(transform),
    opacity: isDragging ? 0.5 : 1,
    cursor: 'grab',
  };

  const categoryColor = {
    chart: '#3b82f6',
    table: '#10b981',
    stat: '#f59e0b',
  }[widget.category];

  return (
    <div
      ref={setNodeRef}
      {...listeners}
      {...attributes}
      style={style}
      className="flex-shrink-0 w-[140px] p-3 rounded-xl transition-all hover:scale-105 select-none"
      data-testid={`shelf-item-${widget.id}`}
      role="option"
      aria-label={`Add ${widget.label} widget`}
    >
      <div
        className="rounded-lg p-3 text-center"
        style={{
          background: 'var(--bg-elevated)',
          border: '1px solid var(--border-subtle)',
        }}
      >
        <div className="text-2xl mb-1">{widget.icon}</div>
        <div
          className="text-xs font-medium leading-tight"
          style={{ color: 'var(--text-primary)' }}
        >
          {widget.label}
        </div>
        <div
          className="mt-1.5 text-[10px] font-medium uppercase tracking-wide px-2 py-0.5 rounded-full inline-block"
          style={{
            background: `${categoryColor}20`,
            color: categoryColor,
          }}
        >
          {widget.category}
        </div>
      </div>
    </div>
  );
}

export const WidgetShelf = memo(function WidgetShelf({ widgets }: WidgetShelfProps) {
  return (
    <div className="sticky top-0 z-10 pb-4">
      <div className="flex items-center justify-between mb-3">
        <h3 className="text-sm font-semibold" style={{ color: 'var(--text-primary)' }}>
          Widget Shelf
        </h3>
        <span className="text-xs" style={{ color: 'var(--text-muted)' }}>
          Drag widgets below to build your view
        </span>
      </div>
      <div
        className="flex gap-2 overflow-x-auto pb-2 scrollbar-thin"
        role="listbox"
        aria-label="Available widgets"
        style={{
          scrollbarWidth: 'thin',
        }}
      >
        {widgets.map(widget => (
          <ShelfItem key={widget.id} widget={widget} />
        ))}
      </div>
    </div>
  );
});
```

**Step 2: Verify the app compiles**

Run:
```bash
cd "/Users/home/Documents/Vibe Coding/Project Ideas/Optimal Compensation Calculator/optimal-compensation-calculator"
npx tsc --noEmit
```
Expected: No errors.

**Step 3: Commit**

```bash
git add src/components/dashboard/WidgetShelf.tsx
git commit -m "feat(dashboard): create WidgetShelf component with draggable thumbnail cards"
```

---

## Task 6: Create WidgetCard Component (Widget Wrapper with Strategy Selector)

**Files:**
- Create: `src/components/dashboard/WidgetCard.tsx`

**Step 1: Create the WidgetCard component**

Create `src/components/dashboard/WidgetCard.tsx`:

```typescript
/**
 * WidgetCard (v2.3.0)
 *
 * Wrapper for each widget placed on the dashboard grid.
 * Provides:
 * - Drag handle for reordering (via header bar)
 * - Strategy selector dropdown (top-right)
 * - Remove button (top-left)
 * - Renders the actual chart/table component inside
 */

import { memo } from 'react';
import { useSortable } from '@dnd-kit/sortable';
import { CSS } from '@dnd-kit/utilities';
import { X, GripVertical } from 'lucide-react';
import type { ComparisonResult } from '../../lib/strategyComparison';
import type { UserInputs } from '../../lib/types';
import { WIDGET_REGISTRY, STRATEGY_IDS } from './widgetRegistry';
import { WidgetRenderer } from './WidgetRenderer';

interface WidgetCardProps {
  instanceId: string;
  widgetType: string;
  strategyId: string;
  comparison: ComparisonResult;
  inputs: UserInputs;
  onRemove: (instanceId: string) => void;
  onStrategyChange: (instanceId: string, strategyId: string) => void;
}

const STRATEGY_COLORS: Record<string, string> = {
  'salary-at-ympe': '#3b82f6',
  'dividends-only': '#10b981',
  'dynamic': '#f59e0b',
};

const STRATEGY_LABELS: Record<string, string> = {
  'salary-at-ympe': 'Salary at YMPE',
  'dividends-only': 'Dividends Only',
  'dynamic': 'Dynamic Optimizer',
};

export const WidgetCard = memo(function WidgetCard({
  instanceId,
  widgetType,
  strategyId,
  comparison,
  inputs,
  onRemove,
  onStrategyChange,
}: WidgetCardProps) {
  const {
    attributes,
    listeners,
    setNodeRef,
    transform,
    transition,
    isDragging,
  } = useSortable({
    id: instanceId,
  });

  const style = {
    transform: CSS.Transform.toString(transform),
    transition,
    opacity: isDragging ? 0.5 : 1,
    zIndex: isDragging ? 50 : 'auto' as any,
  };

  const widget = WIDGET_REGISTRY[widgetType];
  if (!widget) return null;

  return (
    <div
      ref={setNodeRef}
      style={style}
      className="rounded-xl overflow-hidden"
      data-testid={`widget-card-${instanceId}`}
    >
      <div
        className="rounded-xl"
        style={{
          background: 'rgba(0,0,0,0.3)',
          border: isDragging
            ? '2px solid var(--accent-primary)'
            : '1px solid var(--border-subtle)',
        }}
      >
        {/* Header: drag handle + title + controls */}
        <div
          className="flex items-center justify-between px-3 py-2"
          style={{ borderBottom: '1px solid var(--border-subtle)' }}
        >
          {/* Left: remove button */}
          <button
            onClick={() => onRemove(instanceId)}
            className="p-1 rounded-md hover:bg-red-500/20 transition-colors"
            title="Remove widget"
            aria-label={`Remove ${widget.label}`}
          >
            <X size={14} style={{ color: 'var(--text-muted)' }} />
          </button>

          {/* Center: drag handle + title */}
          <div
            className="flex items-center gap-2 flex-1 justify-center cursor-grab active:cursor-grabbing"
            {...attributes}
            {...listeners}
          >
            <GripVertical size={14} style={{ color: 'var(--text-muted)' }} />
            <span className="text-xs font-medium" style={{ color: 'var(--text-primary)' }}>
              {widget.icon} {widget.label}
            </span>
          </div>

          {/* Right: strategy selector pill */}
          <div className="relative">
            <select
              value={strategyId}
              onChange={(e) => onStrategyChange(instanceId, e.target.value)}
              className="text-xs font-medium pl-5 pr-2 py-1 rounded-full appearance-none cursor-pointer"
              style={{
                background: `${STRATEGY_COLORS[strategyId]}20`,
                color: STRATEGY_COLORS[strategyId],
                border: `1px solid ${STRATEGY_COLORS[strategyId]}40`,
              }}
              aria-label={`Strategy for ${widget.label}`}
            >
              {STRATEGY_IDS.map(id => (
                <option key={id} value={id}>
                  {STRATEGY_LABELS[id]}
                </option>
              ))}
            </select>
            {/* Color dot */}
            <span
              className="absolute left-2 top-1/2 -translate-y-1/2 w-2 h-2 rounded-full pointer-events-none"
              style={{ background: STRATEGY_COLORS[strategyId] }}
            />
          </div>
        </div>

        {/* Widget content */}
        <div className="p-4">
          <WidgetRenderer
            widgetType={widgetType}
            strategyId={strategyId}
            comparison={comparison}
            inputs={inputs}
          />
        </div>
      </div>
    </div>
  );
});
```

**Step 2: Verify TypeScript compiles (after WidgetRenderer is created in next task)**

This will be verified after Task 7.

**Step 3: Commit (bundle with Task 7)**

---

## Task 7: Create WidgetRenderer Component

**Files:**
- Create: `src/components/dashboard/WidgetRenderer.tsx`

This is the component that maps a `widgetType` + `strategyId` to the actual chart/table component.

**Step 1: Write the failing test**

Append to `src/lib/__tests__/dashboard.test.ts`:

```typescript
describe('Widget Renderer data extraction', () => {
  it('getStrategyData returns correct strategy from comparison', () => {
    // This tests the helper function that WidgetRenderer uses
    const { getStrategyData } = require('../../components/dashboard/WidgetRenderer');
    const mockComparison = {
      strategies: [
        { id: 'salary-at-ympe', summary: { totalTax: 100 } },
        { id: 'dividends-only', summary: { totalTax: 200 } },
        { id: 'dynamic', summary: { totalTax: 150 } },
      ],
      yearlyData: [
        { strategyId: 'salary-at-ympe', years: [] },
        { strategyId: 'dividends-only', years: [] },
        { strategyId: 'dynamic', years: [] },
      ],
      winner: { lowestTax: 'salary-at-ympe', highestBalance: 'dynamic', bestOverall: 'dynamic' },
    };

    const result = getStrategyData(mockComparison, 'dividends-only');
    expect(result.strategy.id).toBe('dividends-only');
    expect(result.strategy.summary.totalTax).toBe(200);
  });

  it('getStrategyData falls back to first strategy for unknown ID', () => {
    const { getStrategyData } = require('../../components/dashboard/WidgetRenderer');
    const mockComparison = {
      strategies: [
        { id: 'salary-at-ympe', summary: { totalTax: 100 } },
      ],
      yearlyData: [
        { strategyId: 'salary-at-ympe', years: [] },
      ],
      winner: { lowestTax: 'salary-at-ympe', highestBalance: 'salary-at-ympe', bestOverall: 'salary-at-ympe' },
    };

    const result = getStrategyData(mockComparison, 'nonexistent');
    expect(result.strategy.id).toBe('salary-at-ympe');
  });
});
```

**Step 2: Run test to verify it fails**

Run:
```bash
cd "/Users/home/Documents/Vibe Coding/Project Ideas/Optimal Compensation Calculator/optimal-compensation-calculator"
npx vitest run src/lib/__tests__/dashboard.test.ts
```
Expected: FAIL â€” cannot resolve `../../components/dashboard/WidgetRenderer`

**Step 3: Create WidgetRenderer.tsx**

Create `src/components/dashboard/WidgetRenderer.tsx`:

```typescript
/**
 * WidgetRenderer (v2.3.0)
 *
 * Maps widgetType + strategyId to the actual chart/table component.
 * Extracts the right data slice from ComparisonResult based on strategy selection.
 *
 * All chart/table components are reused from existing codebase â€” no new visualizations.
 */

import { memo } from 'react';
import {
  BarChart, Bar, LineChart, Line, XAxis, YAxis, CartesianGrid,
  Tooltip, Legend, ResponsiveContainer, ComposedChart, Area,
} from 'recharts';
import type { ComparisonResult, StrategyResult } from '../../lib/strategyComparison';
import type { UserInputs } from '../../lib/types';
import { formatCurrency, formatPercent } from '../../lib/formatters';
import { AfterTaxWealthTable } from '../charts/AfterTaxWealthTable';
import { ActionPlanTable } from '../charts/ActionPlanTable';
import { YearlyProjection } from '../YearlyProjection';

interface WidgetRendererProps {
  widgetType: string;
  strategyId: string;
  comparison: ComparisonResult;
  inputs: UserInputs;
}

const STRATEGY_COLORS: Record<string, string> = {
  'salary-at-ympe': '#3b82f6',
  'dividends-only': '#10b981',
  'dynamic': '#f59e0b',
};

const TAX_COLORS = {
  personal: '#6366f1',
  corporate: '#f59e0b',
  cpp: '#ec4899',
  ei: '#8b5cf6',
  qpip: '#06b6d4',
  health: '#10b981',
};

const COMP_COLORS = {
  salary: '#6366f1',
  eligible: '#a78bfa',
  nonEligible: '#fbbf24',
  capital: '#34d399',
};

const CustomTooltip = ({ active, payload, label }: any) => {
  if (!active || !payload || !payload.length) return null;
  return (
    <div style={{
      background: 'rgba(22, 22, 30, 0.95)',
      backdropFilter: 'blur(12px)',
      border: '1px solid rgba(255,255,255,0.1)',
      borderRadius: '12px',
      padding: '12px 16px',
      boxShadow: '0 8px 32px rgba(0,0,0,0.4)',
    }}>
      <p style={{ fontWeight: 600, marginBottom: 8, color: 'rgba(255,255,255,0.9)' }}>{label}</p>
      {payload.map((entry: any, index: number) => (
        <div key={index} style={{ display: 'flex', alignItems: 'center', gap: 8, marginBottom: 4, fontSize: '13px' }}>
          <span style={{ width: 8, height: 8, borderRadius: '50%', background: entry.color }} />
          <span style={{ color: 'rgba(255,255,255,0.6)' }}>{entry.name}:</span>
          <span style={{ fontWeight: 600, color: 'rgba(255,255,255,0.95)' }}>
            {typeof entry.value === 'number' && entry.value < 1
              ? formatPercent(entry.value)
              : formatCurrency(entry.value)}
          </span>
        </div>
      ))}
    </div>
  );
};

/** Extract strategy data from comparison result â€” exported for testing */
export function getStrategyData(
  comparison: ComparisonResult,
  strategyId: string
): { strategy: StrategyResult; yearlyData: typeof comparison.yearlyData[0] } {
  const strategy = comparison.strategies.find(s => s.id === strategyId)
    || comparison.strategies[0];
  const yearlyData = comparison.yearlyData.find(d => d.strategyId === strategyId)
    || comparison.yearlyData[0];
  return { strategy, yearlyData };
}

const axisProps = {
  stroke: 'rgba(255,255,255,0.4)',
  fontSize: 11,
  tickLine: false as const,
  axisLine: false as const,
};

const formatCompact = (value: number): string => {
  if (value >= 1000000) return `$${(value / 1000000).toFixed(1)}M`;
  if (value >= 1000) return `$${(value / 1000).toFixed(0)}K`;
  return `$${value}`;
};

export const WidgetRenderer = memo(function WidgetRenderer({
  widgetType,
  strategyId,
  comparison,
  inputs,
}: WidgetRendererProps) {
  const { strategy, yearlyData } = getStrategyData(comparison, strategyId);

  switch (widgetType) {
    case 'total-tax-comparison': {
      const data = comparison.strategies.map(s => ({
        name: s.label,
        value: s.summary.totalTax,
        fill: STRATEGY_COLORS[s.id] || '#6b7280',
      }));
      return (
        <ResponsiveContainer width="100%" height={250}>
          <BarChart data={data} barCategoryGap="30%">
            <CartesianGrid strokeDasharray="3 3" stroke="rgba(255,255,255,0.06)" vertical={false} />
            <XAxis dataKey="name" {...axisProps} />
            <YAxis tickFormatter={formatCompact} {...axisProps} width={60} />
            <Tooltip content={<CustomTooltip />} />
            <Bar dataKey="value" radius={[8, 8, 0, 0]} />
          </BarChart>
        </ResponsiveContainer>
      );
    }

    case 'corporate-balance-over-time': {
      const maxYears = Math.max(...comparison.yearlyData.map(s => s.years.length));
      const data = Array.from({ length: maxYears }, (_, idx) => {
        const dataPoint: Record<string, any> = {
          year: comparison.yearlyData[0]?.years[idx]?.year
            ? `${comparison.yearlyData[0].years[idx].year}` : `Y${idx + 1}`,
        };
        comparison.yearlyData.forEach(sy => {
          const s = comparison.strategies.find(st => st.id === sy.strategyId);
          if (s && sy.years[idx]) {
            dataPoint[s.label] = sy.years[idx].notionalAccounts.corporateInvestments;
          }
        });
        return dataPoint;
      });
      return (
        <ResponsiveContainer width="100%" height={250}>
          <LineChart data={data}>
            <CartesianGrid strokeDasharray="3 3" stroke="rgba(255,255,255,0.06)" vertical={false} />
            <XAxis dataKey="year" {...axisProps} />
            <YAxis tickFormatter={formatCompact} {...axisProps} width={60} />
            <Tooltip content={<CustomTooltip />} />
            <Legend iconType="line" iconSize={12} wrapperStyle={{ fontSize: '11px', paddingTop: '8px', color: 'rgba(255,255,255,0.7)' }} />
            {comparison.strategies.map(s => (
              <Line key={s.id} type="monotone" dataKey={s.label}
                stroke={STRATEGY_COLORS[s.id]} strokeWidth={s.id === strategyId ? 3 : 1.5}
                dot={{ fill: STRATEGY_COLORS[s.id], r: 2, strokeWidth: 0 }} />
            ))}
          </LineChart>
        </ResponsiveContainer>
      );
    }

    case 'cumulative-tax-paid': {
      const maxYears = Math.max(...comparison.yearlyData.map(s => s.years.length));
      const data = Array.from({ length: maxYears }, (_, idx) => {
        const dataPoint: Record<string, any> = {
          year: comparison.yearlyData[0]?.years[idx]?.year
            ? `${comparison.yearlyData[0].years[idx].year}` : `Y${idx + 1}`,
        };
        comparison.yearlyData.forEach(sy => {
          const s = comparison.strategies.find(st => st.id === sy.strategyId);
          if (s) {
            dataPoint[s.label] = sy.years.slice(0, idx + 1).reduce((sum, y) => sum + y.totalTax, 0);
          }
        });
        return dataPoint;
      });
      return (
        <ResponsiveContainer width="100%" height={250}>
          <LineChart data={data}>
            <CartesianGrid strokeDasharray="3 3" stroke="rgba(255,255,255,0.06)" vertical={false} />
            <XAxis dataKey="year" {...axisProps} />
            <YAxis tickFormatter={formatCompact} {...axisProps} width={60} />
            <Tooltip content={<CustomTooltip />} />
            <Legend iconType="line" iconSize={12} wrapperStyle={{ fontSize: '11px', paddingTop: '8px', color: 'rgba(255,255,255,0.7)' }} />
            {comparison.strategies.map(s => (
              <Line key={s.id} type="monotone" dataKey={s.label}
                stroke={STRATEGY_COLORS[s.id]} strokeWidth={s.id === strategyId ? 3 : 1.5}
                dot={{ fill: STRATEGY_COLORS[s.id], r: 2, strokeWidth: 0 }} />
            ))}
          </LineChart>
        </ResponsiveContainer>
      );
    }

    case 'tax-breakdown': {
      const data = [{
        name: strategy.label,
        'Personal Tax': strategy.summary.yearlyResults.reduce((sum, y) => sum + y.personalTax, 0),
        'Corporate Tax': strategy.summary.yearlyResults.reduce((sum, y) => sum + y.corporateTax, 0),
        'CPP/QPP': strategy.summary.yearlyResults.reduce((sum, y) => sum + y.cpp + y.cpp2, 0),
        'EI': strategy.summary.yearlyResults.reduce((sum, y) => sum + y.ei, 0),
        'QPIP': strategy.summary.yearlyResults.reduce((sum, y) => sum + y.qpip, 0),
        'Health Premium': strategy.summary.yearlyResults.reduce((sum, y) => sum + y.healthPremium, 0),
      }];
      return (
        <ResponsiveContainer width="100%" height={250}>
          <BarChart data={data} barCategoryGap="30%">
            <CartesianGrid strokeDasharray="3 3" stroke="rgba(255,255,255,0.06)" vertical={false} />
            <XAxis dataKey="name" {...axisProps} />
            <YAxis tickFormatter={formatCompact} {...axisProps} width={60} />
            <Tooltip content={<CustomTooltip />} />
            <Legend iconType="circle" iconSize={8} wrapperStyle={{ fontSize: '11px', paddingTop: '8px', color: 'rgba(255,255,255,0.7)' }} />
            <Bar dataKey="Personal Tax" stackId="a" fill={TAX_COLORS.personal} />
            <Bar dataKey="Corporate Tax" stackId="a" fill={TAX_COLORS.corporate} />
            <Bar dataKey="CPP/QPP" stackId="a" fill={TAX_COLORS.cpp} />
            <Bar dataKey="EI" stackId="a" fill={TAX_COLORS.ei} />
            <Bar dataKey="QPIP" stackId="a" fill={TAX_COLORS.qpip} />
            <Bar dataKey="Health Premium" stackId="a" fill={TAX_COLORS.health} radius={[8, 8, 0, 0]} />
          </BarChart>
        </ResponsiveContainer>
      );
    }

    case 'compensation-mix': {
      const data = [{
        name: strategy.label,
        'Salary': strategy.summary.yearlyResults.reduce((sum, y) => sum + y.salary, 0),
        'Eligible Div': strategy.summary.yearlyResults.reduce((sum, y) => sum + y.dividends.eligibleDividends, 0),
        'Non-Elig Div': strategy.summary.yearlyResults.reduce((sum, y) => sum + y.dividends.nonEligibleDividends, 0),
        'Capital Div': strategy.summary.yearlyResults.reduce((sum, y) => sum + y.dividends.capitalDividends, 0),
      }];
      return (
        <ResponsiveContainer width="100%" height={250}>
          <BarChart data={data} barCategoryGap="30%">
            <CartesianGrid strokeDasharray="3 3" stroke="rgba(255,255,255,0.06)" vertical={false} />
            <XAxis dataKey="name" {...axisProps} />
            <YAxis tickFormatter={formatCompact} {...axisProps} width={60} />
            <Tooltip content={<CustomTooltip />} />
            <Legend iconType="circle" iconSize={8} wrapperStyle={{ fontSize: '11px', paddingTop: '8px', color: 'rgba(255,255,255,0.7)' }} />
            <Bar dataKey="Salary" stackId="a" fill={COMP_COLORS.salary} />
            <Bar dataKey="Eligible Div" stackId="a" fill={COMP_COLORS.eligible} />
            <Bar dataKey="Non-Elig Div" stackId="a" fill={COMP_COLORS.nonEligible} />
            <Bar dataKey="Capital Div" stackId="a" fill={COMP_COLORS.capital} radius={[8, 8, 0, 0]} />
          </BarChart>
        </ResponsiveContainer>
      );
    }

    case 'rrsp-room': {
      const data = [{
        name: strategy.label,
        'RRSP Room': strategy.summary.totalRRSPRoomGenerated,
        fill: STRATEGY_COLORS[strategy.id] || '#6b7280',
      }];
      return (
        <ResponsiveContainer width="100%" height={250}>
          <BarChart data={data} barCategoryGap="30%">
            <CartesianGrid strokeDasharray="3 3" stroke="rgba(255,255,255,0.06)" vertical={false} />
            <XAxis dataKey="name" {...axisProps} />
            <YAxis tickFormatter={formatCompact} {...axisProps} width={60} />
            <Tooltip content={<CustomTooltip />} />
            <Bar dataKey="RRSP Room" radius={[8, 8, 0, 0]} />
          </BarChart>
        </ResponsiveContainer>
      );
    }

    case 'effective-tax-rate': {
      const data = yearlyData.years.map((y, idx) => ({
        year: `${y.year}`,
        [strategy.label]: y.effectiveIntegratedRate,
      }));
      return (
        <ResponsiveContainer width="100%" height={250}>
          <LineChart data={data}>
            <CartesianGrid strokeDasharray="3 3" stroke="rgba(255,255,255,0.06)" vertical={false} />
            <XAxis dataKey="year" {...axisProps} />
            <YAxis tickFormatter={(v: number) => `${(v * 100).toFixed(0)}%`} {...axisProps} width={50} domain={[0, 'auto']} />
            <Tooltip content={<CustomTooltip />} />
            <Line type="monotone" dataKey={strategy.label}
              stroke={STRATEGY_COLORS[strategy.id]}
              strokeWidth={2}
              dot={{ fill: STRATEGY_COLORS[strategy.id], r: 3, strokeWidth: 0 }} />
          </LineChart>
        </ResponsiveContainer>
      );
    }

    case 'ipp-contributions': {
      if (!yearlyData.years.some(y => y.ipp)) {
        return <div className="text-sm text-center py-8" style={{ color: 'var(--text-muted)' }}>IPP not enabled for this strategy</div>;
      }
      const data = yearlyData.years.map(y => ({
        year: `${y.year}`,
        [strategy.label]: y.ipp?.contribution ?? 0,
      }));
      return (
        <ResponsiveContainer width="100%" height={250}>
          <LineChart data={data}>
            <CartesianGrid strokeDasharray="3 3" stroke="rgba(255,255,255,0.06)" vertical={false} />
            <XAxis dataKey="year" {...axisProps} />
            <YAxis tickFormatter={formatCompact} {...axisProps} width={60} />
            <Tooltip content={<CustomTooltip />} />
            <Line type="monotone" dataKey={strategy.label}
              stroke={STRATEGY_COLORS[strategy.id]}
              strokeWidth={2}
              dot={{ fill: STRATEGY_COLORS[strategy.id], r: 3, strokeWidth: 0 }} />
          </LineChart>
        </ResponsiveContainer>
      );
    }

    case 'compensation-by-year': {
      const data = yearlyData.years.map(y => ({
        year: `Y${y.year}`,
        Salary: y.salary,
        'Capital Div': y.dividends.capitalDividends,
        'Eligible Div': y.dividends.eligibleDividends,
        'Non-Elig Div': y.dividends.nonEligibleDividends,
      }));
      return (
        <ResponsiveContainer width="100%" height={250}>
          <BarChart data={data} barCategoryGap="20%">
            <CartesianGrid strokeDasharray="3 3" stroke="rgba(255,255,255,0.06)" vertical={false} />
            <XAxis dataKey="year" {...axisProps} />
            <YAxis tickFormatter={formatCompact} {...axisProps} width={55} />
            <Tooltip content={<CustomTooltip />} />
            <Legend iconType="circle" iconSize={8} wrapperStyle={{ fontSize: '11px', paddingTop: '8px', color: 'rgba(255,255,255,0.7)' }} />
            <Bar dataKey="Salary" fill={COMP_COLORS.salary} stackId="a" />
            <Bar dataKey="Capital Div" fill={COMP_COLORS.capital} stackId="a" />
            <Bar dataKey="Eligible Div" fill={COMP_COLORS.eligible} stackId="a" />
            <Bar dataKey="Non-Elig Div" fill={COMP_COLORS.nonEligible} stackId="a" radius={[4, 4, 0, 0]} />
          </BarChart>
        </ResponsiveContainer>
      );
    }

    case 'after-tax-wealth':
      return <AfterTaxWealthTable comparison={comparison} />;

    case 'action-plan':
      return <ActionPlanTable yearlyResults={strategy.summary.yearlyResults} />;

    case 'yearly-projection':
      return <YearlyProjection results={strategy.summary.yearlyResults} />;

    case 'key-metrics': {
      const s = strategy.summary;
      return (
        <div className="grid grid-cols-2 gap-3">
          <div className="stat-card">
            <div className="stat-label">Total Compensation</div>
            <div className="stat-value" style={{ fontSize: '1.1rem' }}>{formatCurrency(s.totalCompensation)}</div>
          </div>
          <div className="stat-card">
            <div className="stat-label">Avg Annual Income</div>
            <div className="stat-value" style={{ fontSize: '1.1rem' }}>{formatCurrency(s.averageAnnualIncome)}</div>
          </div>
          <div className="stat-card">
            <div className="stat-label">Final Corp Balance</div>
            <div className={`stat-value ${s.finalCorporateBalance > 0 ? 'positive' : 'negative'}`} style={{ fontSize: '1.1rem' }}>
              {formatCurrency(s.finalCorporateBalance)}
            </div>
          </div>
          <div className="stat-card">
            <div className="stat-label">Effective Tax Rate</div>
            <div className="stat-value" style={{ fontSize: '1.1rem' }}>{formatPercent(s.effectiveTaxRate)}</div>
          </div>
        </div>
      );
    }

    default:
      return (
        <div className="text-sm text-center py-8" style={{ color: 'var(--text-muted)' }}>
          Unknown widget type: {widgetType}
        </div>
      );
  }
});
```

**Step 4: Run test to verify it passes**

Run:
```bash
cd "/Users/home/Documents/Vibe Coding/Project Ideas/Optimal Compensation Calculator/optimal-compensation-calculator"
npx vitest run src/lib/__tests__/dashboard.test.ts
```
Expected: All tests PASS.

**Step 5: Verify TypeScript compiles**

Run:
```bash
cd "/Users/home/Documents/Vibe Coding/Project Ideas/Optimal Compensation Calculator/optimal-compensation-calculator"
npx tsc --noEmit
```
Expected: No errors.

**Step 6: Commit**

```bash
git add src/components/dashboard/WidgetCard.tsx src/components/dashboard/WidgetRenderer.tsx src/lib/__tests__/dashboard.test.ts
git commit -m "feat(dashboard): create WidgetCard with strategy selector and WidgetRenderer with all 13 widget types"
```

---

## Task 8: Create DashboardTab Component

**Files:**
- Create: `src/components/tabs/DashboardTab.tsx`

**Step 1: Create DashboardTab.tsx**

Create `src/components/tabs/DashboardTab.tsx`:

```typescript
/**
 * DashboardTab (v2.3.0)
 *
 * Main tab component for the custom dashboard feature.
 * Manages:
 * - DndContext wrapping shelf + grid
 * - Widget grid state (add, remove, reorder, change strategy)
 * - Persistence to localStorage
 * - Empty state UI
 */

import { memo, useState, useCallback, useEffect } from 'react';
import {
  DndContext,
  DragOverlay,
  closestCenter,
  KeyboardSensor,
  PointerSensor,
  TouchSensor,
  useSensor,
  useSensors,
  type DragStartEvent,
  type DragEndEvent,
} from '@dnd-kit/core';
import {
  SortableContext,
  sortableKeyboardCoordinates,
  rectSortingStrategy,
  arrayMove,
} from '@dnd-kit/sortable';
import type { ComparisonResult } from '../../lib/strategyComparison';
import type { UserInputs } from '../../lib/types';
import { WidgetShelf } from '../dashboard/WidgetShelf';
import { WidgetCard } from '../dashboard/WidgetCard';
import {
  getAvailableWidgets,
  createWidgetInstance,
  WIDGET_REGISTRY,
  type DashboardWidget,
} from '../dashboard/widgetRegistry';
import {
  saveDashboardLayout,
  loadDashboardLayout,
  clearDashboardLayout,
} from '../dashboard/dashboardStorage';

interface DashboardTabProps {
  comparison: ComparisonResult;
  inputs: UserInputs;
}

export const DashboardTab = memo(function DashboardTab({
  comparison,
  inputs,
}: DashboardTabProps) {
  const [widgets, setWidgets] = useState<DashboardWidget[]>(() => {
    const saved = loadDashboardLayout();
    return saved?.widgets ?? [];
  });
  const [activeDragId, setActiveDragId] = useState<string | null>(null);

  const ippEnabled = inputs.considerIPP || inputs.spouseConsiderIPP;
  const availableWidgets = getAvailableWidgets({ ippEnabled });

  // Persist layout on every change
  useEffect(() => {
    saveDashboardLayout({ widgets });
  }, [widgets]);

  const sensors = useSensors(
    useSensor(PointerSensor, { activationConstraint: { distance: 8 } }),
    useSensor(TouchSensor, { activationConstraint: { delay: 200, tolerance: 5 } }),
    useSensor(KeyboardSensor, { coordinateGetter: sortableKeyboardCoordinates }),
  );

  const handleDragStart = useCallback((event: DragStartEvent) => {
    setActiveDragId(String(event.active.id));
  }, []);

  const handleDragEnd = useCallback((event: DragEndEvent) => {
    setActiveDragId(null);
    const { active, over } = event;

    if (!over) return;

    // Case 1: Dragging from shelf to grid (or onto the droppable area)
    const activeData = active.data.current;
    if (activeData?.type === 'shelf-item') {
      const widgetType = activeData.widgetType as string;
      const defaultStrategy = comparison.winner.bestOverall;
      const newWidget = createWidgetInstance(widgetType, defaultStrategy);

      setWidgets(prev => {
        // If dropped on an existing widget, insert before it
        const overIndex = prev.findIndex(w => w.instanceId === String(over.id));
        if (overIndex >= 0) {
          const updated = [...prev];
          updated.splice(overIndex, 0, newWidget);
          return updated;
        }
        // Otherwise append
        return [...prev, newWidget];
      });
      return;
    }

    // Case 2: Reordering within grid
    if (active.id !== over.id) {
      setWidgets(prev => {
        const oldIndex = prev.findIndex(w => w.instanceId === String(active.id));
        const newIndex = prev.findIndex(w => w.instanceId === String(over.id));
        if (oldIndex === -1 || newIndex === -1) return prev;
        return arrayMove(prev, oldIndex, newIndex);
      });
    }
  }, [comparison.winner.bestOverall]);

  const handleRemove = useCallback((instanceId: string) => {
    setWidgets(prev => prev.filter(w => w.instanceId !== instanceId));
  }, []);

  const handleStrategyChange = useCallback((instanceId: string, strategyId: string) => {
    setWidgets(prev =>
      prev.map(w => w.instanceId === instanceId ? { ...w, strategyId } : w)
    );
  }, []);

  const handleReset = useCallback(() => {
    setWidgets([]);
    clearDashboardLayout();
  }, []);

  return (
    <div className="space-y-4">
      <DndContext
        sensors={sensors}
        collisionDetection={closestCenter}
        onDragStart={handleDragStart}
        onDragEnd={handleDragEnd}
      >
        {/* Widget Shelf */}
        <WidgetShelf widgets={availableWidgets} />

        {/* Reset button (only show when widgets exist) */}
        {widgets.length > 0 && (
          <div className="flex justify-end">
            <button
              onClick={handleReset}
              className="text-xs px-3 py-1.5 rounded-lg transition-colors hover:bg-red-500/20"
              style={{
                color: 'var(--text-muted)',
                border: '1px solid var(--border-subtle)',
              }}
            >
              Reset Dashboard
            </button>
          </div>
        )}

        {/* Drop Zone / Grid */}
        {widgets.length === 0 ? (
          /* Empty state */
          <div
            className="border-2 border-dashed rounded-xl p-12 text-center"
            style={{ borderColor: 'var(--border-subtle)' }}
          >
            <div className="text-4xl mb-4">ðŸ“Š</div>
            <p className="text-sm font-medium mb-2" style={{ color: 'var(--text-primary)' }}>
              Drag widgets here to build your comparison view
            </p>
            <p className="text-xs" style={{ color: 'var(--text-muted)' }}>
              Tip: Place the same widget twice with different strategies to compare side by side
            </p>
          </div>
        ) : (
          <SortableContext
            items={widgets.map(w => w.instanceId)}
            strategy={rectSortingStrategy}
          >
            <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
              {widgets.map(widget => (
                <WidgetCard
                  key={widget.instanceId}
                  instanceId={widget.instanceId}
                  widgetType={widget.widgetType}
                  strategyId={widget.strategyId}
                  comparison={comparison}
                  inputs={inputs}
                  onRemove={handleRemove}
                  onStrategyChange={handleStrategyChange}
                />
              ))}
            </div>
          </SortableContext>
        )}

        {/* Drag overlay (ghost while dragging from shelf) */}
        <DragOverlay>
          {activeDragId && activeDragId.startsWith('shelf-') ? (
            <div className="opacity-80 bg-[var(--bg-elevated)] rounded-xl p-3 shadow-xl border border-[var(--accent-primary)]">
              <div className="text-2xl text-center">
                {WIDGET_REGISTRY[activeDragId.replace('shelf-', '')]?.icon ?? 'ðŸ“Š'}
              </div>
              <div className="text-xs text-center mt-1" style={{ color: 'var(--text-primary)' }}>
                {WIDGET_REGISTRY[activeDragId.replace('shelf-', '')]?.label ?? 'Widget'}
              </div>
            </div>
          ) : null}
        </DragOverlay>
      </DndContext>
    </div>
  );
});
```

**Step 2: Verify TypeScript compiles**

Run:
```bash
cd "/Users/home/Documents/Vibe Coding/Project Ideas/Optimal Compensation Calculator/optimal-compensation-calculator"
npx tsc --noEmit
```
Expected: No errors.

**Step 3: Commit**

```bash
git add src/components/tabs/DashboardTab.tsx
git commit -m "feat(dashboard): create DashboardTab with drag-and-drop grid, shelf, persistence"
```

---

## Task 9: Wire DashboardTab into Summary.tsx

**Files:**
- Modify: `src/components/Summary.tsx`

**Step 1: Modify Summary.tsx**

Add import at the top (after the ExportTab import):
```typescript
import { DashboardTab } from './tabs/DashboardTab';
```

Add the dashboard tab rendering in the tab switch section. Find this block:
```typescript
{activeTab === 'details' && (
  <DetailsTab comparison={comparison} inputs={inputs} />
)}
{activeTab === 'export' && (
```

Insert between them:
```typescript
{activeTab === 'dashboard' && (
  <DashboardTab comparison={comparison} inputs={inputs} />
)}
```

**Step 2: Verify TypeScript compiles**

Run:
```bash
cd "/Users/home/Documents/Vibe Coding/Project Ideas/Optimal Compensation Calculator/optimal-compensation-calculator"
npx tsc --noEmit
```
Expected: No errors.

**Step 3: Run full test suite**

Run:
```bash
cd "/Users/home/Documents/Vibe Coding/Project Ideas/Optimal Compensation Calculator/optimal-compensation-calculator"
npx vitest run
```
Expected: All tests pass.

**Step 4: Commit**

```bash
git add src/components/Summary.tsx
git commit -m "feat(dashboard): wire DashboardTab into Summary.tsx tab rendering"
```

---

## Task 10: Integration Tests

**Files:**
- Modify: `src/lib/__tests__/dashboard.test.ts`

**Step 1: Write integration tests**

Append to `src/lib/__tests__/dashboard.test.ts`:

```typescript
import { getDefaultInputs } from '../localStorage';
import { runStrategyComparison } from '../strategyComparison';
import { getAvailableWidgets, createWidgetInstance } from '../../components/dashboard/widgetRegistry';

describe('Dashboard Integration', () => {
  const inputs = {
    ...getDefaultInputs(),
    province: 'ON' as const,
    requiredIncome: 100000,
    annualCorporateRetainedEarnings: 400000,
    corporateInvestmentBalance: 500000,
    planningHorizon: 5,
    salaryStrategy: 'dynamic' as const,
  };
  const comparison = runStrategyComparison(inputs);

  it('all comparison strategies are selectable', () => {
    expect(comparison.strategies).toHaveLength(3);
    const ids = comparison.strategies.map(s => s.id);
    expect(ids).toContain('salary-at-ympe');
    expect(ids).toContain('dividends-only');
    expect(ids).toContain('dynamic');
  });

  it('available widgets count matches registry when IPP disabled', () => {
    const widgets = getAvailableWidgets({ ippEnabled: false });
    // Should have all widgets minus the conditional IPP one
    expect(widgets.length).toBe(12);
  });

  it('available widgets count includes IPP when enabled', () => {
    const widgets = getAvailableWidgets({ ippEnabled: true });
    expect(widgets.length).toBe(13);
  });

  it('createWidgetInstance generates unique IDs', () => {
    const w1 = createWidgetInstance('tax-breakdown', 'dynamic');
    const w2 = createWidgetInstance('tax-breakdown', 'dynamic');
    expect(w1.instanceId).not.toBe(w2.instanceId);
    expect(w1.widgetType).toBe('tax-breakdown');
    expect(w1.strategyId).toBe('dynamic');
  });

  it('getStrategyData extracts correct strategy for each ID', () => {
    const { getStrategyData } = require('../../components/dashboard/WidgetRenderer');
    for (const strategy of comparison.strategies) {
      const result = getStrategyData(comparison, strategy.id);
      expect(result.strategy.id).toBe(strategy.id);
    }
  });

  it('layout round-trips through persistence', () => {
    localStorage.clear();
    const widget1 = createWidgetInstance('total-tax-comparison', 'dynamic');
    const widget2 = createWidgetInstance('action-plan', 'salary-at-ympe');
    const widget3 = createWidgetInstance('key-metrics', 'dividends-only');

    saveDashboardLayout({ widgets: [widget1, widget2, widget3] });
    const loaded = loadDashboardLayout();
    expect(loaded!.widgets).toHaveLength(3);
    expect(loaded!.widgets[0].widgetType).toBe('total-tax-comparison');
    expect(loaded!.widgets[0].strategyId).toBe('dynamic');
    expect(loaded!.widgets[2].strategyId).toBe('dividends-only');
  });
});
```

**Step 2: Run tests**

Run:
```bash
cd "/Users/home/Documents/Vibe Coding/Project Ideas/Optimal Compensation Calculator/optimal-compensation-calculator"
npx vitest run src/lib/__tests__/dashboard.test.ts
```
Expected: All tests PASS.

**Step 3: Run full test suite**

Run:
```bash
cd "/Users/home/Documents/Vibe Coding/Project Ideas/Optimal Compensation Calculator/optimal-compensation-calculator"
npx vitest run
```
Expected: All tests pass (1,449 existing + new dashboard tests).

**Step 4: Commit**

```bash
git add src/lib/__tests__/dashboard.test.ts
git commit -m "test(dashboard): add integration tests for widget selection, persistence, and data extraction"
```

---

## Task 11: Visual Verification & Build Check

**Step 1: Run the build**

Run:
```bash
cd "/Users/home/Documents/Vibe Coding/Project Ideas/Optimal Compensation Calculator/optimal-compensation-calculator"
npm run build
```
Expected: Build succeeds with no errors.

**Step 2: Run the full test suite one final time**

Run:
```bash
cd "/Users/home/Documents/Vibe Coding/Project Ideas/Optimal Compensation Calculator/optimal-compensation-calculator"
npx vitest run
```
Expected: All tests pass.

**Step 3: Verify TypeScript**

Run:
```bash
cd "/Users/home/Documents/Vibe Coding/Project Ideas/Optimal Compensation Calculator/optimal-compensation-calculator"
npx tsc --noEmit
```
Expected: No errors.

**Step 4: Commit any final fixes if needed**

---

## Summary of All New/Modified Files

**New Files (7):**
- `src/components/dashboard/types.ts` â€” Dashboard type definitions
- `src/components/dashboard/widgetRegistry.ts` â€” Widget registry (13 widgets)
- `src/components/dashboard/dashboardStorage.ts` â€” localStorage persistence
- `src/components/dashboard/WidgetShelf.tsx` â€” Draggable shelf component
- `src/components/dashboard/WidgetCard.tsx` â€” Widget wrapper with controls
- `src/components/dashboard/WidgetRenderer.tsx` â€” Maps widget types to components
- `src/components/tabs/DashboardTab.tsx` â€” Main dashboard tab

**Modified Files (2):**
- `src/components/tabs/TabNavigation.tsx` â€” Added 'dashboard' tab
- `src/components/Summary.tsx` â€” Added DashboardTab rendering

**Test File (1):**
- `src/lib/__tests__/dashboard.test.ts` â€” Registry, persistence, integration tests

**New Dependency:**
- `@dnd-kit/core`, `@dnd-kit/sortable`, `@dnd-kit/utilities`
