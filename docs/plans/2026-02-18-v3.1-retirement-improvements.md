# v3.1 Retirement Improvements Implementation Plan

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.

**Goal:** Ship three retirement model improvements in order: (1) inflation-adjusted retirement spending label fix, (2) spousal CPP/OAS modeling, (3) Monte Carlo simulation.

**Architecture:**
Feature 1 is a UI/label fix only — the engine already inflates `retirementSpending` from projection start (`yearIndex`), but the form shows a nominal label with no indication values are real-dollar inputs. We need to clarify this in the UI and ensure the `RetirementIncome` object exposes the inflation-adjusted target so charts can show it.
Feature 2 adds spouse CPP/OAS to the retirement engine: project spouse CPP from `spouseCPPStartAge`/`spouseAverageHistoricalSalary`/`spouseActualRRSPBalance` (already in `UserInputs` but never read in `calculator.ts`), add OAS for spouse, add spouse RRSP/TFSA balances to retirement drawdown, and surface totals in `lifetime` summary.
Feature 3 adds a Monte Carlo engine (`src/lib/monteCarlo.ts`) that runs N simulations with randomised return/inflation sequences and returns percentile bands, plus a new chart component.

**Tech Stack:** TypeScript, Vitest, React 19, Recharts 3, existing `inflateAmount`/`projectCPPBenefit`/`calculateOAS` utilities.

---

## Feature 1: Retirement Spending — Clarify Inflation Semantics

### Background

`retirementSpending` in `UserInputs` is a **today's-dollars** input. The engine inflates it correctly using `yearIndex` (years from projection start, line 520–524 of `calculator.ts`). However:
- The form label gives no hint that the value is in today's dollars
- The `RetirementIncome` interface has no `targetSpending` field, so charts can't show the gap between target and actual income
- The `LifetimeOverviewStats` shows `totalLifetimeSpending` (sum of `afterTaxIncome`), not the inflation-adjusted target total

The fix is: add `targetSpending` to `RetirementIncome`, populate it in `calculateRetirementYear`, update the form tooltip, and update `LifetimeOverviewStats` label to say "after-tax, nominal dollars".

### Task 1: Add `targetSpending` to `RetirementIncome` type

**Files:**
- Modify: `src/lib/types.ts` — `RetirementIncome` interface (around line 166)

**Step 1: Write the failing test**

File: `src/lib/__tests__/retirementDrawdown.test.ts` — add inside `describe('target spending')`:

```typescript
it('exposes inflation-adjusted targetSpending on retirement year', () => {
  const inputs = createLifetimeInputs({
    planningHorizon: 22,
    retirementSpending: 70000,
    inflationRate: 0.02,
  });
  const result = calculateProjection(inputs);
  const firstRetirementYear = result.yearlyResults.find(yr => yr.phase === 'retirement')!;

  // targetSpending should be > 70000 (inflated from year 0 to year 20+)
  expect(firstRetirementYear.retirement!.targetSpending).toBeGreaterThan(70000);
  // Should be roughly 70000 * 1.02^20 ≈ 104040
  expect(firstRetirementYear.retirement!.targetSpending).toBeGreaterThan(100000);
  expect(firstRetirementYear.retirement!.targetSpending).toBeLessThan(115000);
});
```

**Step 2: Run test — verify it fails**

```bash
cd "optimal-compensation-calculator" && npx vitest run src/lib/__tests__/retirementDrawdown.test.ts 2>&1 | grep -E "FAIL|targetSpending"
```
Expected: `Property 'targetSpending' does not exist` TypeScript error or test fail.

**Step 3: Add field to type**

In `src/lib/types.ts`, `RetirementIncome` interface, add after `ippPension`:
```typescript
targetSpending: number;         // Inflation-adjusted spending target for this year
```

**Step 4: Populate in `calculateRetirementYear`**

In `src/lib/calculator.ts`, `calculateRetirementYear` function, in the return object where `retirement` is built (around line 1299–1380), add:
```typescript
targetSpending: inputs.retirementSpending,
```
(`inputs.retirementSpending` is already the inflation-adjusted value passed in from the loop.)

**Step 5: Run test — verify it passes**

```bash
npx vitest run src/lib/__tests__/retirementDrawdown.test.ts 2>&1 | tail -5
```
Expected: all tests pass.

**Step 6: Commit**

```bash
git add src/lib/types.ts src/lib/calculator.ts src/lib/__tests__/retirementDrawdown.test.ts
git commit -m "feat: expose targetSpending on RetirementIncome for chart use"
```

---

### Task 2: Update form tooltip and LifetimeOverviewStats label

**Files:**
- Modify: `src/components/Tooltip.tsx` — `INPUT_TOOLTIPS` for `retirementSpending`
- Modify: `src/components/charts/LifetimeCharts.tsx` — `LifetimeOverviewStats` stat label

**Step 1: Update tooltip**

In `src/components/Tooltip.tsx`, find `INPUT_TOOLTIPS` (or equivalent). Update the `retirementSpending` entry to:
```
"Annual after-tax spending target in retirement, in today's dollars. The model inflates this each year by your inflation rate — so $70,000 today becomes ~$104,000 in year 20 at 2% inflation."
```

**Step 2: Update LifetimeOverviewStats label**

In `src/components/charts/LifetimeCharts.tsx`, `LifetimeOverviewStats`, change the label:
```typescript
// Before:
{ label: 'Total Lifetime Spending', value: formatCurrency(lt.totalLifetimeSpending), positive: true },
// After:
{ label: 'Total Lifetime Spending (nominal)', value: formatCurrency(lt.totalLifetimeSpending), positive: true },
```

**Step 3: Run full test suite**

```bash
npx vitest run 2>&1 | tail -5
```
Expected: all tests pass (no logic change).

**Step 4: Commit**

```bash
git add src/components/Tooltip.tsx src/components/charts/LifetimeCharts.tsx
git commit -m "docs: clarify retirement spending is today's dollars, label lifetime spending as nominal"
```

---

## Feature 2: Spousal CPP/OAS Modeling

### Background

`UserInputs` already has all spouse retirement fields: `spouseCPPStartAge`, `spouseSalaryStartAge`, `spouseAverageHistoricalSalary`, `spouseOASEligible`, `spouseOASStartAge`, `spouseActualRRSPBalance`, `spouseActualTFSABalance`, `spouseRetirementAge`. None are read in `calculator.ts` retirement phase.

The plan:
1. Carry spouse RRSP/TFSA balances into the retirement phase loop
2. Project spouse CPP benefit (same `projectCPPBenefit` call, using spouse earnings)
3. Add spouse OAS per retirement year (same `calculateOAS`, using spouse age + `spouseOASStartAge`)
4. Add spouse RRIF minimum when spouse age ≥ 72
5. Combine spouse CPP + OAS into the household retirement income (reduces drawdown from corporate/RRIF)
6. Expose spouse CPP/OAS totals in `lifetime` summary
7. Surface in `LifetimeOverviewStats`

### Scope limits (YAGNI)

- Spouse has their own RRSP/TFSA but we do NOT model separate spouse drawdown priorities — spouse accounts are treated as household assets.
- No separate spouse spending target — household uses `retirementSpending`.
- No spousal attribution rules on RRSP withdrawals (out of scope for v3.1).

### Task 3: Add spouse retirement types

**Files:**
- Modify: `src/lib/types.ts`

**Step 1: Write failing test**

File: `src/lib/__tests__/retirementDrawdown.test.ts`, add new describe block:

```typescript
describe('spouse CPP/OAS in retirement', () => {
  it('adds spouse CPP income when hasSpouse = true', () => {
    const inputs: UserInputs = {
      ...createLifetimeInputs({
        planningHorizon: 22,
        salaryStrategy: 'dynamic',
      }),
      hasSpouse: true,
      spouseCurrentAge: 42,
      spouseRetirementAge: 65,
      spouseCPPStartAge: 65,
      spouseSalaryStartAge: 22,
      spouseAverageHistoricalSalary: 60000,
      spouseOASEligible: true,
      spouseOASStartAge: 65,
      spouseActualRRSPBalance: 100000,
      spouseActualTFSABalance: 50000,
      spouseRequiredIncome: 50000,
    };
    const result = calculateProjection(inputs);
    const retYears = result.yearlyResults.filter(yr => yr.phase === 'retirement');
    expect(retYears.length).toBeGreaterThan(0);

    // Should have spouse CPP
    const firstRetYear = retYears[0];
    expect(firstRetYear.retirement!.spouseCPPIncome).toBeGreaterThan(0);
  });

  it('adds spouse OAS income when eligible', () => {
    const inputs: UserInputs = {
      ...createLifetimeInputs({ planningHorizon: 22 }),
      hasSpouse: true,
      spouseCurrentAge: 42,
      spouseCPPStartAge: 65,
      spouseSalaryStartAge: 22,
      spouseAverageHistoricalSalary: 60000,
      spouseOASEligible: true,
      spouseOASStartAge: 65,
      spouseActualRRSPBalance: 100000,
      spouseActualTFSABalance: 50000,
      spouseRequiredIncome: 50000,
    };
    const result = calculateProjection(inputs);
    const retYears = result.yearlyResults.filter(yr => yr.phase === 'retirement');

    // Spouse OAS should appear when spouse age >= spouseOASStartAge
    const spouseAge65Year = retYears.find(yr =>
      yr.spouseAge !== undefined && yr.spouseAge >= 65
    );
    if (spouseAge65Year) {
      expect(spouseAge65Year.retirement!.spouseOASNet).toBeGreaterThan(0);
    }
  });

  it('spouse CPP/OAS reduces drawdown from corporate', () => {
    const baseInputs = createLifetimeInputs({ planningHorizon: 25 });
    const spouseInputs: UserInputs = {
      ...baseInputs,
      hasSpouse: true,
      spouseCurrentAge: 45,
      spouseCPPStartAge: 65,
      spouseSalaryStartAge: 22,
      spouseAverageHistoricalSalary: 60000,
      spouseOASEligible: true,
      spouseOASStartAge: 65,
      spouseActualRRSPBalance: 100000,
      spouseActualTFSABalance: 50000,
      spouseRequiredIncome: 50000,
    };

    const baseResult = calculateProjection(baseInputs);
    const spouseResult = calculateProjection(spouseInputs);

    // With spouse CPP/OAS, less needs to come from corporate
    const baseCorp = baseResult.yearlyResults
      .filter(yr => yr.phase === 'retirement')
      .reduce((s, yr) => s + (yr.retirement?.corporateDividends ?? 0), 0);
    const spouseCorp = spouseResult.yearlyResults
      .filter(yr => yr.phase === 'retirement')
      .reduce((s, yr) => s + (yr.retirement?.corporateDividends ?? 0), 0);

    expect(spouseCorp).toBeLessThan(baseCorp);
  });

  it('lifetime summary includes spouse CPP and OAS totals', () => {
    const inputs: UserInputs = {
      ...createLifetimeInputs({ planningHorizon: 45 }),
      hasSpouse: true,
      spouseCurrentAge: 42,
      spouseCPPStartAge: 65,
      spouseSalaryStartAge: 22,
      spouseAverageHistoricalSalary: 60000,
      spouseOASEligible: true,
      spouseOASStartAge: 65,
      spouseActualRRSPBalance: 100000,
      spouseActualTFSABalance: 50000,
      spouseRequiredIncome: 50000,
    };
    const result = calculateProjection(inputs);

    expect(result.lifetime).toBeDefined();
    expect(result.lifetime!.spouseCPPTotalReceived).toBeGreaterThan(0);
    expect(result.lifetime!.spouseOASTotalReceived).toBeGreaterThan(0);
  });
});
```

**Step 2: Run test — verify it fails**

```bash
npx vitest run src/lib/__tests__/retirementDrawdown.test.ts 2>&1 | grep -E "FAIL|spouseCPP|spouseOAS"
```

**Step 3: Extend `RetirementIncome` type**

In `src/lib/types.ts`, `RetirementIncome` interface, add after `ippPension`:
```typescript
spouseCPPIncome: number;        // Spouse annual CPP benefit (0 if no spouse or not yet started)
spouseOASGross: number;         // Spouse OAS before clawback
spouseOASNet: number;           // Spouse OAS after clawback
spouseRRIFWithdrawal: number;   // Spouse RRIF minimum withdrawal
```

**Step 4: Extend `ProjectionSummary.lifetime` type**

In `src/lib/types.ts`, `lifetime` in `ProjectionSummary`, add:
```typescript
spouseCPPTotalReceived: number;
spouseOASTotalReceived: number;
```

**Step 5: Commit type changes**

```bash
git add src/lib/types.ts
git commit -m "feat(types): add spouse CPP/OAS fields to RetirementIncome and lifetime summary"
```

---

### Task 4: Implement spouse CPP/OAS in `calculateProjection`

**Files:**
- Modify: `src/lib/calculator.ts` — retirement phase loop (around lines 485–567)

**Step 1: Project spouse CPP before the retirement loop**

Immediately after `const cppResult = projectCPPBenefit(...)` (line 492–500), add:

```typescript
// Spouse CPP projection (only when hasSpouse = true and spouse has retirement fields)
const spouseHasRetirement = inputs.hasSpouse &&
  inputs.spouseCPPStartAge !== undefined &&
  inputs.spouseCurrentAge !== undefined;

const spouseCPPResult = spouseHasRetirement
  ? projectCPPBenefit({
      birthYear: startingYear - (inputs.spouseCurrentAge ?? currentAge),
      salaryStartAge: inputs.spouseSalaryStartAge ?? 22,
      averageHistoricalSalary: inputs.spouseAverageHistoricalSalary ?? 60000,
      projectedSalaries: cppEarningsHistory.map(() => 0), // Spouse salary not tracked in accumulation loop yet
      currentAge: inputs.spouseCurrentAge ?? currentAge,
      cppStartAge: inputs.spouseCPPStartAge ?? 65,
      inflationRate,
    })
  : null;
```

Note: `cppEarningsHistory` contains primary earner salaries. Spouse salary history in accumulation is not tracked separately (YAGNI — using `spouseAverageHistoricalSalary` for all years via projectedSalaries of zeros lets `projectCPPBenefit` fall back to history). Pass zeros for projected years and the historical average covers pre-projection years.

**Step 2: Carry spouse RRSP/TFSA into retirement**

After `let retAccounts = { ...currentAccounts };` (line 510), add:

```typescript
let retSpouseRRSPBalance = (inputs.hasSpouse ? inputs.spouseActualRRSPBalance ?? 0 : 0);
let retSpouseTFSABalance = (inputs.hasSpouse ? inputs.spouseActualTFSABalance ?? 0 : 0);
let isSpouseRRIF = false;
```

**Step 3: Compute spouse income per retirement year**

Inside the retirement loop (after `const cppIncome = ...`, before `const retResult = ...`), add:

```typescript
// Spouse CPP
const spouseCPPStartAge = inputs.spouseCPPStartAge ?? 65;
const spouseAge = inputs.hasSpouse && inputs.spouseCurrentAge !== undefined
  ? inputs.spouseCurrentAge + yearIndex
  : undefined;
const spouseCPPIncome = (spouseCPPResult && spouseAge !== undefined && spouseAge >= spouseCPPStartAge)
  ? inflateAmount(spouseCPPResult.totalAnnualBenefit, spouseAge - spouseCPPStartAge, inflationRate)
  : 0;

// Spouse OAS
const spouseOASResult = (inputs.hasSpouse && spouseAge !== undefined)
  ? calculateOAS({
      calendarYear,
      age: spouseAge,
      oasStartAge: inputs.spouseOASStartAge ?? 65,
      oasEligible: inputs.spouseOASEligible ?? false,
      baseIncomeBeforeOAS: spouseCPPIncome,
      inflationRate,
    })
  : { grossOAS: 0, clawback: 0, netOAS: 0 };

// Grow spouse RRSP/TFSA balances
retSpouseRRSPBalance *= (1 + inputs.investmentReturnRate);
retSpouseTFSABalance *= (1 + inputs.investmentReturnRate);

// Spouse RRIF minimum (age 72+)
let spouseRRIFWithdrawal = 0;
if (spouseAge !== undefined && spouseAge >= 71 && !isSpouseRRIF) {
  isSpouseRRIF = true; // RRSP converts to RRIF at 71
}
if (isSpouseRRIF && retSpouseRRSPBalance > 0) {
  const spouseRRIFRate = getRRIFMinimumRate(spouseAge!);
  spouseRRIFWithdrawal = retSpouseRRSPBalance * spouseRRIFRate;
  retSpouseRRSPBalance -= spouseRRIFWithdrawal;
}
```

Import `getRRIFMinimumRate` — it's already available from `src/lib/tax/rrif.ts`. Check its export with:
```bash
grep "export function\|export const" src/lib/tax/rrif.ts | head -10
```

**Step 4: Pass spouse income to `calculateRetirementYear` and offset spending gap**

`calculateRetirementYear` takes `retirementSpending` and fills the gap from corporate/RRIF/TFSA. Reduce the spending gap by spouse household income before passing:

In `RetirementYearInputs` interface (around line 1112), add:
```typescript
householdExtraIncome: number;  // Spouse CPP + OAS + RRIF already covered
```

In the `calculateRetirementYear` call (line 532–549), add:
```typescript
householdExtraIncome: spouseCPPIncome + spouseOASResult.netOAS + spouseRRIFWithdrawal,
```

Inside `calculateRetirementYear` (line 1205–1207), adjust:
```typescript
// Before:
const spendingGap = Math.max(0, inputs.retirementSpending - mandatoryAfterTaxEstimate);
// After:
const spendingGap = Math.max(0, inputs.retirementSpending - mandatoryAfterTaxEstimate - inputs.householdExtraIncome);
```

In the retirement result object, add:
```typescript
spouseCPPIncome,
spouseOASGross: spouseOASResult.grossOAS,
spouseOASNet:   spouseOASResult.netOAS,
spouseRRIFWithdrawal,
```

After the retirement loop body (after `isRRIF = retResult.isRRIF;`), update spouse balances:
```typescript
isSpouseRRIF = isSpouseRRIF; // already updated above
// retSpouseRRSPBalance and retSpouseTFSABalance already updated in-loop
```

**Step 5: Run retirement tests**

```bash
npx vitest run src/lib/__tests__/retirementDrawdown.test.ts 2>&1 | tail -10
```

Expected: all tests including new spouse tests pass.

**Step 6: Commit**

```bash
git add src/lib/calculator.ts src/lib/types.ts
git commit -m "feat: add spouse CPP/OAS/RRIF to retirement drawdown engine"
```

---

### Task 5: Update `buildLifetimeSummary` for spouse totals

**Files:**
- Modify: `src/lib/calculator.ts` — `buildLifetimeSummary` (around line 1491)

**Step 1: Add spouse accumulation to summary loop**

In `buildLifetimeSummary`, after `cppTotalReceived += yr.retirement.cppIncome;`, add:
```typescript
spouseCPPTotalReceived += yr.retirement.spouseCPPIncome;
spouseOASTotalReceived += yr.retirement.spouseOASNet;
```

Initialize at top of function:
```typescript
let spouseCPPTotalReceived = 0;
let spouseOASTotalReceived = 0;
```

Add to return object:
```typescript
spouseCPPTotalReceived,
spouseOASTotalReceived,
```

**Step 2: Run full test suite**

```bash
npx vitest run 2>&1 | tail -5
```

**Step 3: Commit**

```bash
git add src/lib/calculator.ts
git commit -m "feat: surface spouse CPP/OAS totals in lifetime summary"
```

---

### Task 6: Surface spouse CPP/OAS in `LifetimeOverviewStats`

**Files:**
- Modify: `src/components/charts/LifetimeCharts.tsx` — `LifetimeOverviewStats`

**Step 1: Add spouse stats conditionally**

In `LifetimeOverviewStats`, after the existing 6-stat grid, add a conditional section:

```typescript
{(lt.spouseCPPTotalReceived > 0 || lt.spouseOASTotalReceived > 0) && (
  <div className="mt-3 grid grid-cols-2 gap-3 text-xs" style={{ color: 'var(--text-muted)' }}>
    <div>Spouse CPP: {formatCurrency(lt.spouseCPPTotalReceived)}</div>
    <div>Spouse OAS: {formatCurrency(lt.spouseOASTotalReceived)}</div>
  </div>
)}
```

**Step 2: Run full test suite + TypeScript check**

```bash
npx tsc --noEmit && npx vitest run 2>&1 | tail -5
```

**Step 3: Commit**

```bash
git add src/components/charts/LifetimeCharts.tsx
git commit -m "feat(ui): show spouse CPP/OAS totals in LifetimeOverviewStats"
```

---

## Feature 3: Monte Carlo Simulation

### Background

The engine currently projects a single path with fixed `investmentReturnRate` and `inflationRate`. Monte Carlo runs N simulations each with randomised annual returns and inflation drawn from normal distributions around the user's inputs, producing 10th/50th/90th percentile wealth paths.

**Parameters:**
- `simulationCount`: 500 (good balance of accuracy vs speed)
- Return distribution: Normal(mean=`investmentReturnRate`, σ=0.12) — 12% annual std dev is typical for balanced portfolio
- Inflation distribution: Normal(mean=`inflationRate`, σ=0.01) — 1% σ on inflation
- Minimum return: -0.40 (cap bad tail)
- Maximum return: +0.60 (cap good tail)

**Output type:**
```typescript
export interface MonteCarloResult {
  simulationCount: number;
  percentiles: {
    p10: number[];   // Wealth at each year, 10th percentile
    p25: number[];
    p50: number[];
    p75: number[];
    p90: number[];
  };
  successRate: number;   // % of simulations where wealth > 0 at end
  medianEstate: number;  // p50 final year value
}
```

**UI:** New `MonteCarloChart` in `src/components/charts/LifetimeCharts.tsx` (area chart with shaded bands). Shown in `DetailsTab` below `RetirementIncomeChart` when lifetime data exists.

---

### Task 7: Monte Carlo engine

**Files:**
- Create: `src/lib/monteCarlo.ts`
- Create: `src/lib/__tests__/monteCarlo.test.ts`

**Step 1: Write the failing tests first**

Create `src/lib/__tests__/monteCarlo.test.ts`:

```typescript
import { describe, it, expect } from 'vitest';
import { runMonteCarlo } from '../monteCarlo';
import { getDefaultInputs } from '../localStorage';
import type { UserInputs } from '../types';

function makeLifetimeInputs(overrides: Partial<UserInputs> = {}): UserInputs {
  return {
    ...getDefaultInputs(),
    currentAge: 45,
    retirementAge: 65,
    planningEndAge: 90,
    planningHorizon: 45,
    requiredIncome: 100000,
    retirementSpending: 70000,
    annualCorporateRetainedEarnings: 200000,
    corporateInvestmentBalance: 500000,
    investmentReturnRate: 0.06,
    inflationRate: 0.02,
    actualRRSPBalance: 200000,
    actualTFSABalance: 100000,
    cppStartAge: 65,
    salaryStartAge: 22,
    averageHistoricalSalary: 70000,
    oasEligible: true,
    oasStartAge: 65,
    lifetimeObjective: 'balanced',
    ...overrides,
  };
}

describe('runMonteCarlo', () => {
  it('returns correct structure', () => {
    const result = runMonteCarlo(makeLifetimeInputs(), { simulationCount: 50 });
    expect(result.simulationCount).toBe(50);
    expect(result.percentiles.p10).toHaveLength(45);
    expect(result.percentiles.p50).toHaveLength(45);
    expect(result.percentiles.p90).toHaveLength(45);
    expect(result.successRate).toBeGreaterThanOrEqual(0);
    expect(result.successRate).toBeLessThanOrEqual(1);
  });

  it('p10 <= p50 <= p90 at every year', () => {
    const result = runMonteCarlo(makeLifetimeInputs(), { simulationCount: 100 });
    for (let i = 0; i < result.percentiles.p10.length; i++) {
      expect(result.percentiles.p10[i]).toBeLessThanOrEqual(result.percentiles.p50[i]);
      expect(result.percentiles.p50[i]).toBeLessThanOrEqual(result.percentiles.p90[i]);
    }
  });

  it('higher return rate produces higher median estate', () => {
    const low  = runMonteCarlo(makeLifetimeInputs({ investmentReturnRate: 0.02 }), { simulationCount: 100 });
    const high = runMonteCarlo(makeLifetimeInputs({ investmentReturnRate: 0.10 }), { simulationCount: 100 });
    expect(high.medianEstate).toBeGreaterThan(low.medianEstate);
  });

  it('successRate is 1.0 for very wealthy scenario', () => {
    const result = runMonteCarlo(
      makeLifetimeInputs({ corporateInvestmentBalance: 10_000_000, retirementSpending: 50000 }),
      { simulationCount: 100 }
    );
    expect(result.successRate).toBeGreaterThan(0.95);
  });

  it('successRate is low for underfunded scenario', () => {
    const result = runMonteCarlo(
      makeLifetimeInputs({
        corporateInvestmentBalance: 50000,
        actualRRSPBalance: 10000,
        actualTFSABalance: 0,
        annualCorporateRetainedEarnings: 20000,
        retirementSpending: 120000,
      }),
      { simulationCount: 100 }
    );
    expect(result.successRate).toBeLessThan(0.5);
  });

  it('non-lifetime inputs return null', () => {
    const result = runMonteCarlo(
      makeLifetimeInputs({ planningHorizon: 5 }),
      { simulationCount: 50 }
    );
    expect(result).toBeNull();
  });
});
```

**Step 2: Run — verify all fail**

```bash
npx vitest run src/lib/__tests__/monteCarlo.test.ts 2>&1 | grep -E "FAIL|Cannot find"
```
Expected: module not found.

**Step 3: Implement `src/lib/monteCarlo.ts`**

```typescript
/**
 * Monte Carlo simulation for lifetime projections.
 *
 * Strategy: run N independent simulations, each with per-year randomised
 * investment returns and inflation drawn from Normal distributions.
 * Collect total wealth (RRSP + TFSA + corporate) at each year across all
 * simulations, then compute percentile bands.
 */

import { calculateProjection } from './calculator';
import type { UserInputs } from './types';

export interface MonteCarloOptions {
  simulationCount?: number;   // Default 500
  returnStdDev?: number;      // Default 0.12
  inflationStdDev?: number;   // Default 0.01
}

export interface MonteCarloResult {
  simulationCount: number;
  percentiles: {
    p10: number[];
    p25: number[];
    p50: number[];
    p75: number[];
    p90: number[];
  };
  successRate: number;
  medianEstate: number;
}

/** Box-Muller transform: standard normal sample */
function randn(): number {
  let u = 0, v = 0;
  while (u === 0) u = Math.random();
  while (v === 0) v = Math.random();
  return Math.sqrt(-2.0 * Math.log(u)) * Math.cos(2.0 * Math.PI * v);
}

function clamp(value: number, min: number, max: number): number {
  return Math.max(min, Math.min(max, value));
}

/**
 * Run Monte Carlo simulation on a lifetime projection.
 * Returns null if the inputs don't produce a retirement phase.
 */
export function runMonteCarlo(
  inputs: UserInputs,
  options: MonteCarloOptions = {},
): MonteCarloResult | null {
  const simulationCount = options.simulationCount ?? 500;
  const returnStdDev    = options.returnStdDev    ?? 0.12;
  const inflationStdDev = options.inflationStdDev ?? 0.01;

  // Quick check: does a deterministic run produce retirement years?
  const pilot = calculateProjection(inputs);
  if (!pilot.lifetime) return null;

  const years = inputs.planningHorizon;

  // wealthByYear[sim][year] = total wealth
  const wealthByYear: number[][] = Array.from({ length: simulationCount }, () =>
    new Array(years).fill(0)
  );
  let successCount = 0;

  for (let sim = 0; sim < simulationCount; sim++) {
    // Build a per-year return sequence
    const perYearReturns = Array.from({ length: years }, () =>
      clamp(
        inputs.investmentReturnRate + randn() * returnStdDev,
        -0.40,
        0.60,
      )
    );
    // Use median inflation across all years (single draw keeps projection coherent)
    const simInflation = clamp(
      inputs.inflationRate + randn() * inflationStdDev,
      0.0,
      0.08,
    );

    // Run projection with perturbed mean return (average of the sequence)
    const meanReturn = perYearReturns.reduce((a, b) => a + b, 0) / years;
    const simInputs: UserInputs = {
      ...inputs,
      investmentReturnRate: meanReturn,
      inflationRate: simInflation,
    };
    const result = calculateProjection(simInputs);

    for (let y = 0; y < years; y++) {
      const yr = result.yearlyResults[y];
      if (!yr) {
        wealthByYear[sim][y] = 0;
      } else {
        const bal = yr.balances;
        wealthByYear[sim][y] = bal
          ? bal.rrspBalance + bal.tfsaBalance + Math.max(0, bal.corporateBalance) + (bal.ippFundBalance ?? 0)
          : Math.max(0, yr.notionalAccounts?.corporateInvestments ?? 0);
      }
    }

    // Success = wealth > 0 in final year
    if (wealthByYear[sim][years - 1] > 0) successCount++;
  }

  // Compute percentiles at each year
  const percentileAt = (sorted: number[], p: number) => {
    const idx = Math.floor(p * (sorted.length - 1));
    return sorted[idx];
  };

  const p10: number[] = [];
  const p25: number[] = [];
  const p50: number[] = [];
  const p75: number[] = [];
  const p90: number[] = [];

  for (let y = 0; y < years; y++) {
    const sorted = wealthByYear.map(s => s[y]).sort((a, b) => a - b);
    p10.push(percentileAt(sorted, 0.10));
    p25.push(percentileAt(sorted, 0.25));
    p50.push(percentileAt(sorted, 0.50));
    p75.push(percentileAt(sorted, 0.75));
    p90.push(percentileAt(sorted, 0.90));
  }

  return {
    simulationCount,
    percentiles: { p10, p25, p50, p75, p90 },
    successRate: successCount / simulationCount,
    medianEstate: p50[years - 1],
  };
}
```

**Step 4: Run tests**

```bash
npx vitest run src/lib/__tests__/monteCarlo.test.ts 2>&1 | tail -8
```
Expected: all 6 tests pass (may be slow ~1-2s due to 100 full projections each).

**Step 5: Commit**

```bash
git add src/lib/monteCarlo.ts src/lib/__tests__/monteCarlo.test.ts
git commit -m "feat: Monte Carlo simulation engine for lifetime projections"
```

---

### Task 8: Monte Carlo chart component

**Files:**
- Modify: `src/components/charts/LifetimeCharts.tsx` — add `MonteCarloChart`
- Modify: `src/components/tabs/DetailsTab.tsx` — wire it in

**Step 1: Add `MonteCarloChart` to `LifetimeCharts.tsx`**

Add at the end of the file:

```typescript
// ── 4. MonteCarloChart ───────────────────────────────────────────────────────

import type { MonteCarloResult } from '../../lib/monteCarlo';

interface MonteCarloChartProps {
  result: MonteCarloResult;
  years: number[];          // Calendar years for X axis
}

export const MonteCarloChart = memo(function MonteCarloChart({
  result,
  years,
}: MonteCarloChartProps) {
  const data = years.map((year, i) => ({
    year,
    p10: result.percentiles.p10[i],
    p25: result.percentiles.p25[i],
    p50: result.percentiles.p50[i],
    p75: result.percentiles.p75[i],
    p90: result.percentiles.p90[i],
  }));

  return (
    <div className="glass-card p-5">
      <div className="flex items-start justify-between mb-1">
        <h3 className="font-semibold" style={{ color: 'var(--text-primary)' }}>
          Monte Carlo — Wealth Projection
        </h3>
        <span
          className="text-xs px-2 py-0.5 rounded-full"
          style={{ background: 'rgba(16,185,129,0.15)', color: '#6ee7b7' }}
        >
          {(result.successRate * 100).toFixed(0)}% success rate
        </span>
      </div>
      <p className="text-xs mb-4" style={{ color: 'var(--text-muted)' }}>
        {result.simulationCount} simulations · shaded bands show 10th–90th and 25th–75th percentiles
      </p>
      <ResponsiveContainer width="100%" height={300}>
        <AreaChart data={data}>
          <CartesianGrid strokeDasharray="3 3" stroke="rgba(255,255,255,0.06)" vertical={false} />
          <XAxis dataKey="year" {...axisProps} />
          <YAxis tickFormatter={formatCompact} {...axisProps} width={60} />
          <Tooltip content={<CustomTooltip />} />
          {/* Outer band: p10-p90 */}
          <Area type="monotone" dataKey="p90" stroke="none" fill="#10b981" fillOpacity={0.12} legendType="none" />
          <Area type="monotone" dataKey="p10" stroke="none" fill="#10b981" fillOpacity={0} legendType="none" />
          {/* Inner band: p25-p75 */}
          <Area type="monotone" dataKey="p75" stroke="none" fill="#10b981" fillOpacity={0.20} legendType="none" />
          <Area type="monotone" dataKey="p25" stroke="none" fill="#10b981" fillOpacity={0} legendType="none" />
          {/* Median line */}
          <Line type="monotone" dataKey="p50" stroke="#6ee7b7" strokeWidth={2} dot={false} name="Median" />
        </AreaChart>
      </ResponsiveContainer>
      <div className="mt-3 flex gap-4 text-xs" style={{ color: 'var(--text-muted)' }}>
        <span><span style={{ color: '#6ee7b7' }}>—</span> Median</span>
        <span><span style={{ opacity: 0.4 }}>■</span> 25th–75th %ile</span>
        <span><span style={{ opacity: 0.2 }}>■</span> 10th–90th %ile</span>
        <span>Median estate: {formatCompact(result.medianEstate)}</span>
      </div>
    </div>
  );
});
```

Note: `Line` is not yet imported from recharts — add it to the import at the top of the file.

**Step 2: Wire into `DetailsTab`**

In `src/components/tabs/DetailsTab.tsx`:

1. Add imports:
```typescript
import { useEffect, useState } from 'react'; // add useState, useEffect if not present
import { runMonteCarlo, type MonteCarloResult } from '../../lib/monteCarlo';
import { MonteCarloChart } from '../charts/LifetimeCharts';
```

2. Add state and effect inside the component (after `hasLifetime`):
```typescript
const [monteCarloResult, setMonteCarloResult] = useState<MonteCarloResult | null>(null);

useEffect(() => {
  if (!hasLifetime) return;
  // Run in a timeout to avoid blocking the UI render
  const id = setTimeout(() => {
    const result = runMonteCarlo(inputs, { simulationCount: 500 });
    setMonteCarloResult(result);
  }, 0);
  return () => clearTimeout(id);
}, [hasLifetime, inputs]);
```

3. Add the chart in the Lifetime Analysis section, after `RetirementIncomeChart`:
```typescript
{monteCarloResult && (
  <MonteCarloChart
    result={monteCarloResult}
    years={comparison.yearlyData[0].years.map(y => y.calendarYear ?? y.year)}
  />
)}
{!monteCarloResult && hasLifetime && (
  <div className="glass-card p-5 text-center text-sm" style={{ color: 'var(--text-muted)' }}>
    Running Monte Carlo simulation…
  </div>
)}
```

**Step 3: TypeScript check + full test suite**

```bash
npx tsc --noEmit && npx vitest run 2>&1 | tail -5
```
Expected: clean.

**Step 4: Commit**

```bash
git add src/components/charts/LifetimeCharts.tsx src/components/tabs/DetailsTab.tsx
git commit -m "feat(ui): Monte Carlo chart in Details tab lifetime section"
```

---

## Final Verification

```bash
npx tsc --noEmit && npx vitest run 2>&1 | tail -8
```

All tests green. No TypeScript errors.

---

## Notes for Implementer

- `inflateAmount(base, years, rate)` computes `base * (1 + rate)^years`. It's imported from `src/lib/tax/index.ts`.
- `getRRIFMinimumRate` — verify the exact export name in `src/lib/tax/rrif.ts` before using.
- `projectCPPBenefit` is in `src/lib/tax/cpp.ts`. When spouse has only historical salary (no projected salaries), passing an array of zeros for `projectedSalaries` is intentional — the CPP calculation uses `averageHistoricalSalary` for pre-projection years.
- Monte Carlo runs 500 × 45-year projections ≈ 22,500 full engine runs. At ~2ms/run in production JS this is ~45s — too slow for synchronous. The `setTimeout(() => {...}, 0)` in the effect defers to idle time and shows a loading state.
- If 45s is too slow in practice, reduce `simulationCount` to 200 or implement a Web Worker. Do not optimise prematurely — measure first.
- The `Line` component from recharts needs to be imported in `LifetimeCharts.tsx`. Check the existing import at line 3–7 and add it.
